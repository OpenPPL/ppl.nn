// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LLMCUDAOPPARAMS_PPL_NN_LLM_CUDA_PMX_H_
#define FLATBUFFERS_GENERATED_LLMCUDAOPPARAMS_PPL_NN_LLM_CUDA_PMX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace ppl {
namespace nn {
namespace llm {
namespace cuda {
namespace pmx {

struct ColumnParallelLinearParam;
struct ColumnParallelLinearParamBuilder;

struct GELUParam;
struct GELUParamBuilder;

struct KeyValueCacheParam;
struct KeyValueCacheParamBuilder;

struct LayerNormParam;
struct LayerNormParamBuilder;

struct MultiHeadAttentionParam;
struct MultiHeadAttentionParamBuilder;

struct ParallelEmbeddingParam;
struct ParallelEmbeddingParamBuilder;

struct RMSNormParam;
struct RMSNormParamBuilder;

struct RotaryPositionEmbeddingParam;
struct RotaryPositionEmbeddingParamBuilder;

struct RowParallelLinearParam;
struct RowParallelLinearParamBuilder;

struct MultiHeadCacheAttentionParam;
struct MultiHeadCacheAttentionParamBuilder;

struct ReshapeParam;
struct ReshapeParamBuilder;

struct SliceParam;
struct SliceParamBuilder;

struct SplitParam;
struct SplitParamBuilder;

struct SwishParam;
struct SwishParamBuilder;

struct VisionEmbeddingParam;
struct VisionEmbeddingParamBuilder;

struct OpParam;
struct OpParamBuilder;

enum OpParamType : uint8_t {
  OpParamType_NONE = 0,
  OpParamType_ColumnParallelLinearParam = 1,
  OpParamType_GELUParam = 2,
  OpParamType_KeyValueCacheParam = 3,
  OpParamType_LayerNormParam = 4,
  OpParamType_MultiHeadAttentionParam = 5,
  OpParamType_ParallelEmbeddingParam = 6,
  OpParamType_RMSNormParam = 7,
  OpParamType_RotaryPositionEmbeddingParam = 8,
  OpParamType_RowParallelLinearParam = 9,
  OpParamType_MultiHeadCacheAttentionParam = 10,
  OpParamType_VisionEmbeddingParam = 11,
  OpParamType_ReshapeParam = 12,
  OpParamType_SliceParam = 13,
  OpParamType_SplitParam = 14,
  OpParamType_SwishParam = 15,
  OpParamType_MIN = OpParamType_NONE,
  OpParamType_MAX = OpParamType_SwishParam
};

inline const OpParamType (&EnumValuesOpParamType())[16] {
  static const OpParamType values[] = {
    OpParamType_NONE,
    OpParamType_ColumnParallelLinearParam,
    OpParamType_GELUParam,
    OpParamType_KeyValueCacheParam,
    OpParamType_LayerNormParam,
    OpParamType_MultiHeadAttentionParam,
    OpParamType_ParallelEmbeddingParam,
    OpParamType_RMSNormParam,
    OpParamType_RotaryPositionEmbeddingParam,
    OpParamType_RowParallelLinearParam,
    OpParamType_MultiHeadCacheAttentionParam,
    OpParamType_VisionEmbeddingParam,
    OpParamType_ReshapeParam,
    OpParamType_SliceParam,
    OpParamType_SplitParam,
    OpParamType_SwishParam
  };
  return values;
}

inline const char * const *EnumNamesOpParamType() {
  static const char * const names[17] = {
    "NONE",
    "ColumnParallelLinearParam",
    "GELUParam",
    "KeyValueCacheParam",
    "LayerNormParam",
    "MultiHeadAttentionParam",
    "ParallelEmbeddingParam",
    "RMSNormParam",
    "RotaryPositionEmbeddingParam",
    "RowParallelLinearParam",
    "MultiHeadCacheAttentionParam",
    "VisionEmbeddingParam",
    "ReshapeParam",
    "SliceParam",
    "SplitParam",
    "SwishParam",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpParamType(OpParamType e) {
  if (flatbuffers::IsOutRange(e, OpParamType_NONE, OpParamType_SwishParam)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpParamType()[index];
}

template<typename T> struct OpParamTypeTraits {
  static const OpParamType enum_value = OpParamType_NONE;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::ColumnParallelLinearParam> {
  static const OpParamType enum_value = OpParamType_ColumnParallelLinearParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::GELUParam> {
  static const OpParamType enum_value = OpParamType_GELUParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::KeyValueCacheParam> {
  static const OpParamType enum_value = OpParamType_KeyValueCacheParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::LayerNormParam> {
  static const OpParamType enum_value = OpParamType_LayerNormParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::MultiHeadAttentionParam> {
  static const OpParamType enum_value = OpParamType_MultiHeadAttentionParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::ParallelEmbeddingParam> {
  static const OpParamType enum_value = OpParamType_ParallelEmbeddingParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::RMSNormParam> {
  static const OpParamType enum_value = OpParamType_RMSNormParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::RotaryPositionEmbeddingParam> {
  static const OpParamType enum_value = OpParamType_RotaryPositionEmbeddingParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::RowParallelLinearParam> {
  static const OpParamType enum_value = OpParamType_RowParallelLinearParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::MultiHeadCacheAttentionParam> {
  static const OpParamType enum_value = OpParamType_MultiHeadCacheAttentionParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::VisionEmbeddingParam> {
  static const OpParamType enum_value = OpParamType_VisionEmbeddingParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::ReshapeParam> {
  static const OpParamType enum_value = OpParamType_ReshapeParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::SliceParam> {
  static const OpParamType enum_value = OpParamType_SliceParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::SplitParam> {
  static const OpParamType enum_value = OpParamType_SplitParam;
};

template<> struct OpParamTypeTraits<ppl::nn::llm::cuda::pmx::SwishParam> {
  static const OpParamType enum_value = OpParamType_SwishParam;
};

bool VerifyOpParamType(flatbuffers::Verifier &verifier, const void *obj, OpParamType type);
bool VerifyOpParamTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ColumnParallelLinearParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColumnParallelLinearParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IN_FEATURES = 4,
    VT_OUT_FEATURES = 6,
    VT_BIAS_TERM = 8,
    VT_GATHER_OUTPUT = 10
  };
  int32_t in_features() const {
    return GetField<int32_t>(VT_IN_FEATURES, 0);
  }
  int32_t out_features() const {
    return GetField<int32_t>(VT_OUT_FEATURES, 0);
  }
  bool bias_term() const {
    return GetField<uint8_t>(VT_BIAS_TERM, 0) != 0;
  }
  bool gather_output() const {
    return GetField<uint8_t>(VT_GATHER_OUTPUT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IN_FEATURES, 4) &&
           VerifyField<int32_t>(verifier, VT_OUT_FEATURES, 4) &&
           VerifyField<uint8_t>(verifier, VT_BIAS_TERM, 1) &&
           VerifyField<uint8_t>(verifier, VT_GATHER_OUTPUT, 1) &&
           verifier.EndTable();
  }
};

struct ColumnParallelLinearParamBuilder {
  typedef ColumnParallelLinearParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_features(int32_t in_features) {
    fbb_.AddElement<int32_t>(ColumnParallelLinearParam::VT_IN_FEATURES, in_features, 0);
  }
  void add_out_features(int32_t out_features) {
    fbb_.AddElement<int32_t>(ColumnParallelLinearParam::VT_OUT_FEATURES, out_features, 0);
  }
  void add_bias_term(bool bias_term) {
    fbb_.AddElement<uint8_t>(ColumnParallelLinearParam::VT_BIAS_TERM, static_cast<uint8_t>(bias_term), 0);
  }
  void add_gather_output(bool gather_output) {
    fbb_.AddElement<uint8_t>(ColumnParallelLinearParam::VT_GATHER_OUTPUT, static_cast<uint8_t>(gather_output), 0);
  }
  explicit ColumnParallelLinearParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColumnParallelLinearParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColumnParallelLinearParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColumnParallelLinearParam> CreateColumnParallelLinearParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t in_features = 0,
    int32_t out_features = 0,
    bool bias_term = false,
    bool gather_output = false) {
  ColumnParallelLinearParamBuilder builder_(_fbb);
  builder_.add_out_features(out_features);
  builder_.add_in_features(in_features);
  builder_.add_gather_output(gather_output);
  builder_.add_bias_term(bias_term);
  return builder_.Finish();
}

struct GELUParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GELUParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPROXIMATE = 4
  };
  bool approximate() const {
    return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_APPROXIMATE, 1) &&
           verifier.EndTable();
  }
};

struct GELUParamBuilder {
  typedef GELUParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_approximate(bool approximate) {
    fbb_.AddElement<uint8_t>(GELUParam::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);
  }
  explicit GELUParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GELUParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GELUParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<GELUParam> CreateGELUParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool approximate = false) {
  GELUParamBuilder builder_(_fbb);
  builder_.add_approximate(approximate);
  return builder_.Finish();
}

struct KeyValueCacheParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyValueCacheParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_LAYER = 4,
    VT_LAYER_IDX = 6,
    VT_QUANT_BIT = 8,
    VT_QUANT_GROUP = 10,
    VT_NUM_REPEAT = 12,
    VT_CACHE_MODE = 14,
    VT_CACHE_LAYOUT = 16
  };
  int32_t num_layer() const {
    return GetField<int32_t>(VT_NUM_LAYER, 0);
  }
  int32_t layer_idx() const {
    return GetField<int32_t>(VT_LAYER_IDX, 0);
  }
  int32_t quant_bit() const {
    return GetField<int32_t>(VT_QUANT_BIT, 0);
  }
  int32_t quant_group() const {
    return GetField<int32_t>(VT_QUANT_GROUP, 0);
  }
  int32_t num_repeat() const {
    return GetField<int32_t>(VT_NUM_REPEAT, 0);
  }
  int32_t cache_mode() const {
    return GetField<int32_t>(VT_CACHE_MODE, 0);
  }
  int32_t cache_layout() const {
    return GetField<int32_t>(VT_CACHE_LAYOUT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_LAYER, 4) &&
           VerifyField<int32_t>(verifier, VT_LAYER_IDX, 4) &&
           VerifyField<int32_t>(verifier, VT_QUANT_BIT, 4) &&
           VerifyField<int32_t>(verifier, VT_QUANT_GROUP, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_REPEAT, 4) &&
           VerifyField<int32_t>(verifier, VT_CACHE_MODE, 4) &&
           VerifyField<int32_t>(verifier, VT_CACHE_LAYOUT, 4) &&
           verifier.EndTable();
  }
};

struct KeyValueCacheParamBuilder {
  typedef KeyValueCacheParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_layer(int32_t num_layer) {
    fbb_.AddElement<int32_t>(KeyValueCacheParam::VT_NUM_LAYER, num_layer, 0);
  }
  void add_layer_idx(int32_t layer_idx) {
    fbb_.AddElement<int32_t>(KeyValueCacheParam::VT_LAYER_IDX, layer_idx, 0);
  }
  void add_quant_bit(int32_t quant_bit) {
    fbb_.AddElement<int32_t>(KeyValueCacheParam::VT_QUANT_BIT, quant_bit, 0);
  }
  void add_quant_group(int32_t quant_group) {
    fbb_.AddElement<int32_t>(KeyValueCacheParam::VT_QUANT_GROUP, quant_group, 0);
  }
  void add_num_repeat(int32_t num_repeat) {
    fbb_.AddElement<int32_t>(KeyValueCacheParam::VT_NUM_REPEAT, num_repeat, 0);
  }
  void add_cache_mode(int32_t cache_mode) {
    fbb_.AddElement<int32_t>(KeyValueCacheParam::VT_CACHE_MODE, cache_mode, 0);
  }
  void add_cache_layout(int32_t cache_layout) {
    fbb_.AddElement<int32_t>(KeyValueCacheParam::VT_CACHE_LAYOUT, cache_layout, 0);
  }
  explicit KeyValueCacheParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<KeyValueCacheParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValueCacheParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValueCacheParam> CreateKeyValueCacheParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_layer = 0,
    int32_t layer_idx = 0,
    int32_t quant_bit = 0,
    int32_t quant_group = 0,
    int32_t num_repeat = 0,
    int32_t cache_mode = 0,
    int32_t cache_layout = 0) {
  KeyValueCacheParamBuilder builder_(_fbb);
  builder_.add_cache_layout(cache_layout);
  builder_.add_cache_mode(cache_mode);
  builder_.add_num_repeat(num_repeat);
  builder_.add_quant_group(quant_group);
  builder_.add_quant_bit(quant_bit);
  builder_.add_layer_idx(layer_idx);
  builder_.add_num_layer(num_layer);
  return builder_.Finish();
}

struct LayerNormParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerNormParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTWISE_AFFINE = 4,
    VT_AXIS = 6,
    VT_EPS = 8,
    VT_SKIP_TERM = 10
  };
  bool elementwise_affine() const {
    return GetField<uint8_t>(VT_ELEMENTWISE_AFFINE, 0) != 0;
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  bool skip_term() const {
    return GetField<uint8_t>(VT_SKIP_TERM, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ELEMENTWISE_AFFINE, 1) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           VerifyField<uint8_t>(verifier, VT_SKIP_TERM, 1) &&
           verifier.EndTable();
  }
};

struct LayerNormParamBuilder {
  typedef LayerNormParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elementwise_affine(bool elementwise_affine) {
    fbb_.AddElement<uint8_t>(LayerNormParam::VT_ELEMENTWISE_AFFINE, static_cast<uint8_t>(elementwise_affine), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(LayerNormParam::VT_AXIS, axis, 0);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(LayerNormParam::VT_EPS, eps, 0.0f);
  }
  void add_skip_term(bool skip_term) {
    fbb_.AddElement<uint8_t>(LayerNormParam::VT_SKIP_TERM, static_cast<uint8_t>(skip_term), 0);
  }
  explicit LayerNormParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LayerNormParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerNormParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerNormParam> CreateLayerNormParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool elementwise_affine = false,
    int32_t axis = 0,
    float eps = 0.0f,
    bool skip_term = false) {
  LayerNormParamBuilder builder_(_fbb);
  builder_.add_eps(eps);
  builder_.add_axis(axis);
  builder_.add_skip_term(skip_term);
  builder_.add_elementwise_affine(elementwise_affine);
  return builder_.Finish();
}

struct MultiHeadAttentionParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MultiHeadAttentionParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_HEADS = 4,
    VT_NUM_KV_HEADS = 6,
    VT_HEAD_DIM = 8,
    VT_IS_CAUSAL = 10
  };
  int32_t num_heads() const {
    return GetField<int32_t>(VT_NUM_HEADS, 0);
  }
  int32_t num_kv_heads() const {
    return GetField<int32_t>(VT_NUM_KV_HEADS, 0);
  }
  int32_t head_dim() const {
    return GetField<int32_t>(VT_HEAD_DIM, 0);
  }
  bool is_causal() const {
    return GetField<uint8_t>(VT_IS_CAUSAL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_HEADS, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_KV_HEADS, 4) &&
           VerifyField<int32_t>(verifier, VT_HEAD_DIM, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_CAUSAL, 1) &&
           verifier.EndTable();
  }
};

struct MultiHeadAttentionParamBuilder {
  typedef MultiHeadAttentionParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_heads(int32_t num_heads) {
    fbb_.AddElement<int32_t>(MultiHeadAttentionParam::VT_NUM_HEADS, num_heads, 0);
  }
  void add_num_kv_heads(int32_t num_kv_heads) {
    fbb_.AddElement<int32_t>(MultiHeadAttentionParam::VT_NUM_KV_HEADS, num_kv_heads, 0);
  }
  void add_head_dim(int32_t head_dim) {
    fbb_.AddElement<int32_t>(MultiHeadAttentionParam::VT_HEAD_DIM, head_dim, 0);
  }
  void add_is_causal(bool is_causal) {
    fbb_.AddElement<uint8_t>(MultiHeadAttentionParam::VT_IS_CAUSAL, static_cast<uint8_t>(is_causal), 0);
  }
  explicit MultiHeadAttentionParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MultiHeadAttentionParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MultiHeadAttentionParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<MultiHeadAttentionParam> CreateMultiHeadAttentionParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_heads = 0,
    int32_t num_kv_heads = 0,
    int32_t head_dim = 0,
    bool is_causal = false) {
  MultiHeadAttentionParamBuilder builder_(_fbb);
  builder_.add_head_dim(head_dim);
  builder_.add_num_kv_heads(num_kv_heads);
  builder_.add_num_heads(num_heads);
  builder_.add_is_causal(is_causal);
  return builder_.Finish();
}

struct ParallelEmbeddingParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParallelEmbeddingParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_EMBEDDINGS = 4,
    VT_EMBEDDING_DIMS = 6,
    VT_PADDING_IDX = 8,
    VT_MAX_NORM = 10,
    VT_NORM_TYPE = 12
  };
  int32_t num_embeddings() const {
    return GetField<int32_t>(VT_NUM_EMBEDDINGS, 0);
  }
  int32_t embedding_dims() const {
    return GetField<int32_t>(VT_EMBEDDING_DIMS, 0);
  }
  int32_t padding_idx() const {
    return GetField<int32_t>(VT_PADDING_IDX, 0);
  }
  float max_norm() const {
    return GetField<float>(VT_MAX_NORM, 0.0f);
  }
  float norm_type() const {
    return GetField<float>(VT_NORM_TYPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_EMBEDDINGS, 4) &&
           VerifyField<int32_t>(verifier, VT_EMBEDDING_DIMS, 4) &&
           VerifyField<int32_t>(verifier, VT_PADDING_IDX, 4) &&
           VerifyField<float>(verifier, VT_MAX_NORM, 4) &&
           VerifyField<float>(verifier, VT_NORM_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct ParallelEmbeddingParamBuilder {
  typedef ParallelEmbeddingParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_embeddings(int32_t num_embeddings) {
    fbb_.AddElement<int32_t>(ParallelEmbeddingParam::VT_NUM_EMBEDDINGS, num_embeddings, 0);
  }
  void add_embedding_dims(int32_t embedding_dims) {
    fbb_.AddElement<int32_t>(ParallelEmbeddingParam::VT_EMBEDDING_DIMS, embedding_dims, 0);
  }
  void add_padding_idx(int32_t padding_idx) {
    fbb_.AddElement<int32_t>(ParallelEmbeddingParam::VT_PADDING_IDX, padding_idx, 0);
  }
  void add_max_norm(float max_norm) {
    fbb_.AddElement<float>(ParallelEmbeddingParam::VT_MAX_NORM, max_norm, 0.0f);
  }
  void add_norm_type(float norm_type) {
    fbb_.AddElement<float>(ParallelEmbeddingParam::VT_NORM_TYPE, norm_type, 0.0f);
  }
  explicit ParallelEmbeddingParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ParallelEmbeddingParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParallelEmbeddingParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParallelEmbeddingParam> CreateParallelEmbeddingParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_embeddings = 0,
    int32_t embedding_dims = 0,
    int32_t padding_idx = 0,
    float max_norm = 0.0f,
    float norm_type = 0.0f) {
  ParallelEmbeddingParamBuilder builder_(_fbb);
  builder_.add_norm_type(norm_type);
  builder_.add_max_norm(max_norm);
  builder_.add_padding_idx(padding_idx);
  builder_.add_embedding_dims(embedding_dims);
  builder_.add_num_embeddings(num_embeddings);
  return builder_.Finish();
}

struct RMSNormParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RMSNormParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_EPS = 6,
    VT_SKIP_TERM = 8
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  bool skip_term() const {
    return GetField<uint8_t>(VT_SKIP_TERM, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           VerifyField<uint8_t>(verifier, VT_SKIP_TERM, 1) &&
           verifier.EndTable();
  }
};

struct RMSNormParamBuilder {
  typedef RMSNormParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(RMSNormParam::VT_AXIS, axis, 0);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(RMSNormParam::VT_EPS, eps, 0.0f);
  }
  void add_skip_term(bool skip_term) {
    fbb_.AddElement<uint8_t>(RMSNormParam::VT_SKIP_TERM, static_cast<uint8_t>(skip_term), 0);
  }
  explicit RMSNormParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RMSNormParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RMSNormParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<RMSNormParam> CreateRMSNormParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    float eps = 0.0f,
    bool skip_term = false) {
  RMSNormParamBuilder builder_(_fbb);
  builder_.add_eps(eps);
  builder_.add_axis(axis);
  builder_.add_skip_term(skip_term);
  return builder_.Finish();
}

struct RotaryPositionEmbeddingParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RotaryPositionEmbeddingParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYPASS_KEY = 4,
    VT_ROTARY_DIM = 6,
    VT_THETA = 8
  };
  int32_t bypass_key() const {
    return GetField<int32_t>(VT_BYPASS_KEY, 0);
  }
  int32_t rotary_dim() const {
    return GetField<int32_t>(VT_ROTARY_DIM, 0);
  }
  float theta() const {
    return GetField<float>(VT_THETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BYPASS_KEY, 4) &&
           VerifyField<int32_t>(verifier, VT_ROTARY_DIM, 4) &&
           VerifyField<float>(verifier, VT_THETA, 4) &&
           verifier.EndTable();
  }
};

struct RotaryPositionEmbeddingParamBuilder {
  typedef RotaryPositionEmbeddingParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bypass_key(int32_t bypass_key) {
    fbb_.AddElement<int32_t>(RotaryPositionEmbeddingParam::VT_BYPASS_KEY, bypass_key, 0);
  }
  void add_rotary_dim(int32_t rotary_dim) {
    fbb_.AddElement<int32_t>(RotaryPositionEmbeddingParam::VT_ROTARY_DIM, rotary_dim, 0);
  }
  void add_theta(float theta) {
    fbb_.AddElement<float>(RotaryPositionEmbeddingParam::VT_THETA, theta, 0.0f);
  }
  explicit RotaryPositionEmbeddingParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RotaryPositionEmbeddingParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RotaryPositionEmbeddingParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<RotaryPositionEmbeddingParam> CreateRotaryPositionEmbeddingParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bypass_key = 0,
    int32_t rotary_dim = 0,
    float theta = 0.0f) {
  RotaryPositionEmbeddingParamBuilder builder_(_fbb);
  builder_.add_theta(theta);
  builder_.add_rotary_dim(rotary_dim);
  builder_.add_bypass_key(bypass_key);
  return builder_.Finish();
}

struct RowParallelLinearParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RowParallelLinearParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IN_FEATURES = 4,
    VT_OUT_FEATURES = 6,
    VT_BIAS_TERM = 8,
    VT_INPUT_IS_PARALLEL = 10
  };
  int32_t in_features() const {
    return GetField<int32_t>(VT_IN_FEATURES, 0);
  }
  int32_t out_features() const {
    return GetField<int32_t>(VT_OUT_FEATURES, 0);
  }
  bool bias_term() const {
    return GetField<uint8_t>(VT_BIAS_TERM, 0) != 0;
  }
  bool input_is_parallel() const {
    return GetField<uint8_t>(VT_INPUT_IS_PARALLEL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IN_FEATURES, 4) &&
           VerifyField<int32_t>(verifier, VT_OUT_FEATURES, 4) &&
           VerifyField<uint8_t>(verifier, VT_BIAS_TERM, 1) &&
           VerifyField<uint8_t>(verifier, VT_INPUT_IS_PARALLEL, 1) &&
           verifier.EndTable();
  }
};

struct RowParallelLinearParamBuilder {
  typedef RowParallelLinearParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_features(int32_t in_features) {
    fbb_.AddElement<int32_t>(RowParallelLinearParam::VT_IN_FEATURES, in_features, 0);
  }
  void add_out_features(int32_t out_features) {
    fbb_.AddElement<int32_t>(RowParallelLinearParam::VT_OUT_FEATURES, out_features, 0);
  }
  void add_bias_term(bool bias_term) {
    fbb_.AddElement<uint8_t>(RowParallelLinearParam::VT_BIAS_TERM, static_cast<uint8_t>(bias_term), 0);
  }
  void add_input_is_parallel(bool input_is_parallel) {
    fbb_.AddElement<uint8_t>(RowParallelLinearParam::VT_INPUT_IS_PARALLEL, static_cast<uint8_t>(input_is_parallel), 0);
  }
  explicit RowParallelLinearParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RowParallelLinearParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RowParallelLinearParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<RowParallelLinearParam> CreateRowParallelLinearParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t in_features = 0,
    int32_t out_features = 0,
    bool bias_term = false,
    bool input_is_parallel = false) {
  RowParallelLinearParamBuilder builder_(_fbb);
  builder_.add_out_features(out_features);
  builder_.add_in_features(in_features);
  builder_.add_input_is_parallel(input_is_parallel);
  builder_.add_bias_term(bias_term);
  return builder_.Finish();
}

struct MultiHeadCacheAttentionParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MultiHeadCacheAttentionParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_HEADS = 4,
    VT_NUM_KV_HEADS = 6,
    VT_HEAD_DIM = 8,
    VT_IS_CAUSAL = 10,
    VT_NUM_LAYER = 12,
    VT_LAYER_IDX = 14,
    VT_QUANT_BIT = 16,
    VT_QUANT_GROUP = 18,
    VT_CACHE_MODE = 20,
    VT_CACHE_LAYOUT = 22
  };
  int32_t num_heads() const {
    return GetField<int32_t>(VT_NUM_HEADS, 0);
  }
  int32_t num_kv_heads() const {
    return GetField<int32_t>(VT_NUM_KV_HEADS, 0);
  }
  int32_t head_dim() const {
    return GetField<int32_t>(VT_HEAD_DIM, 0);
  }
  bool is_causal() const {
    return GetField<uint8_t>(VT_IS_CAUSAL, 0) != 0;
  }
  int32_t num_layer() const {
    return GetField<int32_t>(VT_NUM_LAYER, 0);
  }
  int32_t layer_idx() const {
    return GetField<int32_t>(VT_LAYER_IDX, 0);
  }
  int32_t quant_bit() const {
    return GetField<int32_t>(VT_QUANT_BIT, 0);
  }
  int32_t quant_group() const {
    return GetField<int32_t>(VT_QUANT_GROUP, 0);
  }
  int32_t cache_mode() const {
    return GetField<int32_t>(VT_CACHE_MODE, 0);
  }
  int32_t cache_layout() const {
    return GetField<int32_t>(VT_CACHE_LAYOUT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_HEADS, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_KV_HEADS, 4) &&
           VerifyField<int32_t>(verifier, VT_HEAD_DIM, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_CAUSAL, 1) &&
           VerifyField<int32_t>(verifier, VT_NUM_LAYER, 4) &&
           VerifyField<int32_t>(verifier, VT_LAYER_IDX, 4) &&
           VerifyField<int32_t>(verifier, VT_QUANT_BIT, 4) &&
           VerifyField<int32_t>(verifier, VT_QUANT_GROUP, 4) &&
           VerifyField<int32_t>(verifier, VT_CACHE_MODE, 4) &&
           VerifyField<int32_t>(verifier, VT_CACHE_LAYOUT, 4) &&
           verifier.EndTable();
  }
};

struct MultiHeadCacheAttentionParamBuilder {
  typedef MultiHeadCacheAttentionParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_heads(int32_t num_heads) {
    fbb_.AddElement<int32_t>(MultiHeadCacheAttentionParam::VT_NUM_HEADS, num_heads, 0);
  }
  void add_num_kv_heads(int32_t num_kv_heads) {
    fbb_.AddElement<int32_t>(MultiHeadCacheAttentionParam::VT_NUM_KV_HEADS, num_kv_heads, 0);
  }
  void add_head_dim(int32_t head_dim) {
    fbb_.AddElement<int32_t>(MultiHeadCacheAttentionParam::VT_HEAD_DIM, head_dim, 0);
  }
  void add_is_causal(bool is_causal) {
    fbb_.AddElement<uint8_t>(MultiHeadCacheAttentionParam::VT_IS_CAUSAL, static_cast<uint8_t>(is_causal), 0);
  }
  void add_num_layer(int32_t num_layer) {
    fbb_.AddElement<int32_t>(MultiHeadCacheAttentionParam::VT_NUM_LAYER, num_layer, 0);
  }
  void add_layer_idx(int32_t layer_idx) {
    fbb_.AddElement<int32_t>(MultiHeadCacheAttentionParam::VT_LAYER_IDX, layer_idx, 0);
  }
  void add_quant_bit(int32_t quant_bit) {
    fbb_.AddElement<int32_t>(MultiHeadCacheAttentionParam::VT_QUANT_BIT, quant_bit, 0);
  }
  void add_quant_group(int32_t quant_group) {
    fbb_.AddElement<int32_t>(MultiHeadCacheAttentionParam::VT_QUANT_GROUP, quant_group, 0);
  }
  void add_cache_mode(int32_t cache_mode) {
    fbb_.AddElement<int32_t>(MultiHeadCacheAttentionParam::VT_CACHE_MODE, cache_mode, 0);
  }
  void add_cache_layout(int32_t cache_layout) {
    fbb_.AddElement<int32_t>(MultiHeadCacheAttentionParam::VT_CACHE_LAYOUT, cache_layout, 0);
  }
  explicit MultiHeadCacheAttentionParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MultiHeadCacheAttentionParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MultiHeadCacheAttentionParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<MultiHeadCacheAttentionParam> CreateMultiHeadCacheAttentionParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_heads = 0,
    int32_t num_kv_heads = 0,
    int32_t head_dim = 0,
    bool is_causal = false,
    int32_t num_layer = 0,
    int32_t layer_idx = 0,
    int32_t quant_bit = 0,
    int32_t quant_group = 0,
    int32_t cache_mode = 0,
    int32_t cache_layout = 0) {
  MultiHeadCacheAttentionParamBuilder builder_(_fbb);
  builder_.add_cache_layout(cache_layout);
  builder_.add_cache_mode(cache_mode);
  builder_.add_quant_group(quant_group);
  builder_.add_quant_bit(quant_bit);
  builder_.add_layer_idx(layer_idx);
  builder_.add_num_layer(num_layer);
  builder_.add_head_dim(head_dim);
  builder_.add_num_kv_heads(num_kv_heads);
  builder_.add_num_heads(num_heads);
  builder_.add_is_causal(is_causal);
  return builder_.Finish();
}

struct ReshapeParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALLOWZERO = 4,
    VT_CONSTANT_SHAPE_DATA = 6
  };
  int32_t allowzero() const {
    return GetField<int32_t>(VT_ALLOWZERO, 0);
  }
  const flatbuffers::Vector<int64_t> *constant_shape_data() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CONSTANT_SHAPE_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ALLOWZERO, 4) &&
           VerifyOffset(verifier, VT_CONSTANT_SHAPE_DATA) &&
           verifier.VerifyVector(constant_shape_data()) &&
           verifier.EndTable();
  }
};

struct ReshapeParamBuilder {
  typedef ReshapeParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_allowzero(int32_t allowzero) {
    fbb_.AddElement<int32_t>(ReshapeParam::VT_ALLOWZERO, allowzero, 0);
  }
  void add_constant_shape_data(flatbuffers::Offset<flatbuffers::Vector<int64_t>> constant_shape_data) {
    fbb_.AddOffset(ReshapeParam::VT_CONSTANT_SHAPE_DATA, constant_shape_data);
  }
  explicit ReshapeParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReshapeParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeParam> CreateReshapeParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t allowzero = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> constant_shape_data = 0) {
  ReshapeParamBuilder builder_(_fbb);
  builder_.add_constant_shape_data(constant_shape_data);
  builder_.add_allowzero(allowzero);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReshapeParam> CreateReshapeParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t allowzero = 0,
    const std::vector<int64_t> *constant_shape_data = nullptr) {
  auto constant_shape_data__ = constant_shape_data ? _fbb.CreateVector<int64_t>(*constant_shape_data) : 0;
  return ppl::nn::llm::cuda::pmx::CreateReshapeParam(
      _fbb,
      allowzero,
      constant_shape_data__);
}

struct SliceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STARTS = 4,
    VT_ENDS = 6,
    VT_AXES = 8,
    VT_STEPS = 10
  };
  const flatbuffers::Vector<int64_t> *starts() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STARTS);
  }
  const flatbuffers::Vector<int64_t> *ends() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ENDS);
  }
  const flatbuffers::Vector<int64_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXES);
  }
  const flatbuffers::Vector<int64_t> *steps() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STEPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STARTS) &&
           verifier.VerifyVector(starts()) &&
           VerifyOffset(verifier, VT_ENDS) &&
           verifier.VerifyVector(ends()) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           VerifyOffset(verifier, VT_STEPS) &&
           verifier.VerifyVector(steps()) &&
           verifier.EndTable();
  }
};

struct SliceParamBuilder {
  typedef SliceParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_starts(flatbuffers::Offset<flatbuffers::Vector<int64_t>> starts) {
    fbb_.AddOffset(SliceParam::VT_STARTS, starts);
  }
  void add_ends(flatbuffers::Offset<flatbuffers::Vector<int64_t>> ends) {
    fbb_.AddOffset(SliceParam::VT_ENDS, ends);
  }
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes) {
    fbb_.AddOffset(SliceParam::VT_AXES, axes);
  }
  void add_steps(flatbuffers::Offset<flatbuffers::Vector<int64_t>> steps) {
    fbb_.AddOffset(SliceParam::VT_STEPS, steps);
  }
  explicit SliceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SliceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceParam> CreateSliceParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> starts = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> ends = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> steps = 0) {
  SliceParamBuilder builder_(_fbb);
  builder_.add_steps(steps);
  builder_.add_axes(axes);
  builder_.add_ends(ends);
  builder_.add_starts(starts);
  return builder_.Finish();
}

inline flatbuffers::Offset<SliceParam> CreateSliceParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *starts = nullptr,
    const std::vector<int64_t> *ends = nullptr,
    const std::vector<int64_t> *axes = nullptr,
    const std::vector<int64_t> *steps = nullptr) {
  auto starts__ = starts ? _fbb.CreateVector<int64_t>(*starts) : 0;
  auto ends__ = ends ? _fbb.CreateVector<int64_t>(*ends) : 0;
  auto axes__ = axes ? _fbb.CreateVector<int64_t>(*axes) : 0;
  auto steps__ = steps ? _fbb.CreateVector<int64_t>(*steps) : 0;
  return ppl::nn::llm::cuda::pmx::CreateSliceParam(
      _fbb,
      starts__,
      ends__,
      axes__,
      steps__);
}

struct SplitParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_SPLIT_POINT = 6,
    VT_CONSTANT_SPLIT_DATA = 8
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *split_point() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SPLIT_POINT);
  }
  const flatbuffers::Vector<int64_t> *constant_split_data() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CONSTANT_SPLIT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyOffset(verifier, VT_SPLIT_POINT) &&
           verifier.VerifyVector(split_point()) &&
           VerifyOffset(verifier, VT_CONSTANT_SPLIT_DATA) &&
           verifier.VerifyVector(constant_split_data()) &&
           verifier.EndTable();
  }
};

struct SplitParamBuilder {
  typedef SplitParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SplitParam::VT_AXIS, axis, 0);
  }
  void add_split_point(flatbuffers::Offset<flatbuffers::Vector<int32_t>> split_point) {
    fbb_.AddOffset(SplitParam::VT_SPLIT_POINT, split_point);
  }
  void add_constant_split_data(flatbuffers::Offset<flatbuffers::Vector<int64_t>> constant_split_data) {
    fbb_.AddOffset(SplitParam::VT_CONSTANT_SPLIT_DATA, constant_split_data);
  }
  explicit SplitParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SplitParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitParam> CreateSplitParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> split_point = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> constant_split_data = 0) {
  SplitParamBuilder builder_(_fbb);
  builder_.add_constant_split_data(constant_split_data);
  builder_.add_split_point(split_point);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<SplitParam> CreateSplitParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    const std::vector<int32_t> *split_point = nullptr,
    const std::vector<int64_t> *constant_split_data = nullptr) {
  auto split_point__ = split_point ? _fbb.CreateVector<int32_t>(*split_point) : 0;
  auto constant_split_data__ = constant_split_data ? _fbb.CreateVector<int64_t>(*constant_split_data) : 0;
  return ppl::nn::llm::cuda::pmx::CreateSplitParam(
      _fbb,
      axis,
      split_point__,
      constant_split_data__);
}

struct SwishParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SwishParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
};

struct SwishParamBuilder {
  typedef SwishParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SwishParam::VT_BETA, beta, 0.0f);
  }
  explicit SwishParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SwishParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SwishParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SwishParam> CreateSwishParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SwishParamBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct VisionEmbeddingParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VisionEmbeddingParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HIDDEN_DIM = 4,
    VT_IMAGE_SIZE = 6,
    VT_PATCH_SIZE = 8
  };
  int32_t hidden_dim() const {
    return GetField<int32_t>(VT_HIDDEN_DIM, 0);
  }
  int32_t image_size() const {
    return GetField<int32_t>(VT_IMAGE_SIZE, 0);
  }
  int32_t patch_size() const {
    return GetField<int32_t>(VT_PATCH_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HIDDEN_DIM, 4) &&
           VerifyField<int32_t>(verifier, VT_IMAGE_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_PATCH_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct VisionEmbeddingParamBuilder {
  typedef VisionEmbeddingParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hidden_dim(int32_t hidden_dim) {
    fbb_.AddElement<int32_t>(VisionEmbeddingParam::VT_HIDDEN_DIM, hidden_dim, 0);
  }
  void add_image_size(int32_t image_size) {
    fbb_.AddElement<int32_t>(VisionEmbeddingParam::VT_IMAGE_SIZE, image_size, 0);
  }
  void add_patch_size(int32_t patch_size) {
    fbb_.AddElement<int32_t>(VisionEmbeddingParam::VT_PATCH_SIZE, patch_size, 0);
  }
  explicit VisionEmbeddingParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VisionEmbeddingParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VisionEmbeddingParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<VisionEmbeddingParam> CreateVisionEmbeddingParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hidden_dim = 0,
    int32_t image_size = 0,
    int32_t patch_size = 0) {
  VisionEmbeddingParamBuilder builder_(_fbb);
  builder_.add_patch_size(patch_size);
  builder_.add_image_size(image_size);
  builder_.add_hidden_dim(hidden_dim);
  return builder_.Finish();
}

struct OpParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  ppl::nn::llm::cuda::pmx::OpParamType value_type() const {
    return static_cast<ppl::nn::llm::cuda::pmx::OpParamType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ppl::nn::llm::cuda::pmx::ColumnParallelLinearParam *value_as_ColumnParallelLinearParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_ColumnParallelLinearParam ? static_cast<const ppl::nn::llm::cuda::pmx::ColumnParallelLinearParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::GELUParam *value_as_GELUParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_GELUParam ? static_cast<const ppl::nn::llm::cuda::pmx::GELUParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::KeyValueCacheParam *value_as_KeyValueCacheParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_KeyValueCacheParam ? static_cast<const ppl::nn::llm::cuda::pmx::KeyValueCacheParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::LayerNormParam *value_as_LayerNormParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_LayerNormParam ? static_cast<const ppl::nn::llm::cuda::pmx::LayerNormParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::MultiHeadAttentionParam *value_as_MultiHeadAttentionParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_MultiHeadAttentionParam ? static_cast<const ppl::nn::llm::cuda::pmx::MultiHeadAttentionParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::ParallelEmbeddingParam *value_as_ParallelEmbeddingParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_ParallelEmbeddingParam ? static_cast<const ppl::nn::llm::cuda::pmx::ParallelEmbeddingParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::RMSNormParam *value_as_RMSNormParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_RMSNormParam ? static_cast<const ppl::nn::llm::cuda::pmx::RMSNormParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::RotaryPositionEmbeddingParam *value_as_RotaryPositionEmbeddingParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_RotaryPositionEmbeddingParam ? static_cast<const ppl::nn::llm::cuda::pmx::RotaryPositionEmbeddingParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::RowParallelLinearParam *value_as_RowParallelLinearParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_RowParallelLinearParam ? static_cast<const ppl::nn::llm::cuda::pmx::RowParallelLinearParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::MultiHeadCacheAttentionParam *value_as_MultiHeadCacheAttentionParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_MultiHeadCacheAttentionParam ? static_cast<const ppl::nn::llm::cuda::pmx::MultiHeadCacheAttentionParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::VisionEmbeddingParam *value_as_VisionEmbeddingParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_VisionEmbeddingParam ? static_cast<const ppl::nn::llm::cuda::pmx::VisionEmbeddingParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::ReshapeParam *value_as_ReshapeParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_ReshapeParam ? static_cast<const ppl::nn::llm::cuda::pmx::ReshapeParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::SliceParam *value_as_SliceParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_SliceParam ? static_cast<const ppl::nn::llm::cuda::pmx::SliceParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::SplitParam *value_as_SplitParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_SplitParam ? static_cast<const ppl::nn::llm::cuda::pmx::SplitParam *>(value()) : nullptr;
  }
  const ppl::nn::llm::cuda::pmx::SwishParam *value_as_SwishParam() const {
    return value_type() == ppl::nn::llm::cuda::pmx::OpParamType_SwishParam ? static_cast<const ppl::nn::llm::cuda::pmx::SwishParam *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyOpParamType(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ppl::nn::llm::cuda::pmx::ColumnParallelLinearParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::ColumnParallelLinearParam>() const {
  return value_as_ColumnParallelLinearParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::GELUParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::GELUParam>() const {
  return value_as_GELUParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::KeyValueCacheParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::KeyValueCacheParam>() const {
  return value_as_KeyValueCacheParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::LayerNormParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::LayerNormParam>() const {
  return value_as_LayerNormParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::MultiHeadAttentionParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::MultiHeadAttentionParam>() const {
  return value_as_MultiHeadAttentionParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::ParallelEmbeddingParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::ParallelEmbeddingParam>() const {
  return value_as_ParallelEmbeddingParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::RMSNormParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::RMSNormParam>() const {
  return value_as_RMSNormParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::RotaryPositionEmbeddingParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::RotaryPositionEmbeddingParam>() const {
  return value_as_RotaryPositionEmbeddingParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::RowParallelLinearParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::RowParallelLinearParam>() const {
  return value_as_RowParallelLinearParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::MultiHeadCacheAttentionParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::MultiHeadCacheAttentionParam>() const {
  return value_as_MultiHeadCacheAttentionParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::VisionEmbeddingParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::VisionEmbeddingParam>() const {
  return value_as_VisionEmbeddingParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::ReshapeParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::ReshapeParam>() const {
  return value_as_ReshapeParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::SliceParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::SliceParam>() const {
  return value_as_SliceParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::SplitParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::SplitParam>() const {
  return value_as_SplitParam();
}

template<> inline const ppl::nn::llm::cuda::pmx::SwishParam *OpParam::value_as<ppl::nn::llm::cuda::pmx::SwishParam>() const {
  return value_as_SwishParam();
}

struct OpParamBuilder {
  typedef OpParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(ppl::nn::llm::cuda::pmx::OpParamType value_type) {
    fbb_.AddElement<uint8_t>(OpParam::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(OpParam::VT_VALUE, value);
  }
  explicit OpParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpParam> CreateOpParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::llm::cuda::pmx::OpParamType value_type = ppl::nn::llm::cuda::pmx::OpParamType_NONE,
    flatbuffers::Offset<void> value = 0) {
  OpParamBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline bool VerifyOpParamType(flatbuffers::Verifier &verifier, const void *obj, OpParamType type) {
  switch (type) {
    case OpParamType_NONE: {
      return true;
    }
    case OpParamType_ColumnParallelLinearParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::ColumnParallelLinearParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_GELUParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::GELUParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_KeyValueCacheParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::KeyValueCacheParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_LayerNormParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::LayerNormParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_MultiHeadAttentionParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::MultiHeadAttentionParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_ParallelEmbeddingParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::ParallelEmbeddingParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_RMSNormParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::RMSNormParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_RotaryPositionEmbeddingParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::RotaryPositionEmbeddingParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_RowParallelLinearParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::RowParallelLinearParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_MultiHeadCacheAttentionParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::MultiHeadCacheAttentionParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_VisionEmbeddingParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::VisionEmbeddingParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_ReshapeParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::ReshapeParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_SliceParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::SliceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_SplitParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::SplitParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_SwishParam: {
      auto ptr = reinterpret_cast<const ppl::nn::llm::cuda::pmx::SwishParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpParamTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpParamType(
        verifier,  values->Get(i), types->GetEnum<OpParamType>(i))) {
      return false;
    }
  }
  return true;
}

inline const ppl::nn::llm::cuda::pmx::OpParam *GetOpParam(const void *buf) {
  return flatbuffers::GetRoot<ppl::nn::llm::cuda::pmx::OpParam>(buf);
}

inline const ppl::nn::llm::cuda::pmx::OpParam *GetSizePrefixedOpParam(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ppl::nn::llm::cuda::pmx::OpParam>(buf);
}

inline bool VerifyOpParamBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ppl::nn::llm::cuda::pmx::OpParam>(nullptr);
}

inline bool VerifySizePrefixedOpParamBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ppl::nn::llm::cuda::pmx::OpParam>(nullptr);
}

inline void FinishOpParamBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ppl::nn::llm::cuda::pmx::OpParam> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOpParamBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ppl::nn::llm::cuda::pmx::OpParam> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace pmx
}  // namespace cuda
}  // namespace llm
}  // namespace nn
}  // namespace ppl

#endif  // FLATBUFFERS_GENERATED_LLMCUDAOPPARAMS_PPL_NN_LLM_CUDA_PMX_H_
