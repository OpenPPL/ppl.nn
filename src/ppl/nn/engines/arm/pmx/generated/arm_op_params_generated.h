// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ARMOPPARAMS_PPL_NN_PMX_ARM_H_
#define FLATBUFFERS_GENERATED_ARMOPPARAMS_PPL_NN_PMX_ARM_H_

#include "flatbuffers/flatbuffers.h"

namespace ppl {
namespace nn {
namespace pmx {
namespace arm {

struct OutputData;
struct OutputDataBuilder;

struct FusionData;
struct FusionDataBuilder;

struct ConvAlgoInfo;
struct ConvAlgoInfoBuilder;

struct ConvParamInfo;
struct ConvParamInfoBuilder;

struct ConvData;
struct ConvDataBuilder;

struct FCAlgoInfo;
struct FCAlgoInfoBuilder;

struct FCParamInfo;
struct FCParamInfoBuilder;

struct FullConnectData;
struct FullConnectDataBuilder;

struct ChannelShuffleParam;
struct ChannelShuffleParamBuilder;

struct ShapeMatrixP;
struct ShapeMatrixPBuilder;

struct ShapeOperationParam;
struct ShapeOperationParamBuilder;

struct PmxOpData;
struct PmxOpDataBuilder;

struct OpData;
struct OpDataBuilder;

enum PmxOpType : uint8_t {
  PmxOpType_NONE = 0,
  PmxOpType_ChannelShuffleParam = 1,
  PmxOpType_ShapeOperationParam = 2,
  PmxOpType_MIN = PmxOpType_NONE,
  PmxOpType_MAX = PmxOpType_ShapeOperationParam
};

inline const PmxOpType (&EnumValuesPmxOpType())[3] {
  static const PmxOpType values[] = {
    PmxOpType_NONE,
    PmxOpType_ChannelShuffleParam,
    PmxOpType_ShapeOperationParam
  };
  return values;
}

inline const char * const *EnumNamesPmxOpType() {
  static const char * const names[4] = {
    "NONE",
    "ChannelShuffleParam",
    "ShapeOperationParam",
    nullptr
  };
  return names;
}

inline const char *EnumNamePmxOpType(PmxOpType e) {
  if (flatbuffers::IsOutRange(e, PmxOpType_NONE, PmxOpType_ShapeOperationParam)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPmxOpType()[index];
}

template<typename T> struct PmxOpTypeTraits {
  static const PmxOpType enum_value = PmxOpType_NONE;
};

template<> struct PmxOpTypeTraits<ppl::nn::pmx::arm::ChannelShuffleParam> {
  static const PmxOpType enum_value = PmxOpType_ChannelShuffleParam;
};

template<> struct PmxOpTypeTraits<ppl::nn::pmx::arm::ShapeOperationParam> {
  static const PmxOpType enum_value = PmxOpType_ShapeOperationParam;
};

bool VerifyPmxOpType(flatbuffers::Verifier &verifier, const void *obj, PmxOpType type);
bool VerifyPmxOpTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum PrivateDataType : uint8_t {
  PrivateDataType_NONE = 0,
  PrivateDataType_OutputData = 1,
  PrivateDataType_FusionData = 2,
  PrivateDataType_ConvData = 3,
  PrivateDataType_FullConnectData = 4,
  PrivateDataType_PmxOpData = 5,
  PrivateDataType_MIN = PrivateDataType_NONE,
  PrivateDataType_MAX = PrivateDataType_PmxOpData
};

inline const PrivateDataType (&EnumValuesPrivateDataType())[6] {
  static const PrivateDataType values[] = {
    PrivateDataType_NONE,
    PrivateDataType_OutputData,
    PrivateDataType_FusionData,
    PrivateDataType_ConvData,
    PrivateDataType_FullConnectData,
    PrivateDataType_PmxOpData
  };
  return values;
}

inline const char * const *EnumNamesPrivateDataType() {
  static const char * const names[7] = {
    "NONE",
    "OutputData",
    "FusionData",
    "ConvData",
    "FullConnectData",
    "PmxOpData",
    nullptr
  };
  return names;
}

inline const char *EnumNamePrivateDataType(PrivateDataType e) {
  if (flatbuffers::IsOutRange(e, PrivateDataType_NONE, PrivateDataType_PmxOpData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPrivateDataType()[index];
}

template<typename T> struct PrivateDataTypeTraits {
  static const PrivateDataType enum_value = PrivateDataType_NONE;
};

template<> struct PrivateDataTypeTraits<ppl::nn::pmx::arm::OutputData> {
  static const PrivateDataType enum_value = PrivateDataType_OutputData;
};

template<> struct PrivateDataTypeTraits<ppl::nn::pmx::arm::FusionData> {
  static const PrivateDataType enum_value = PrivateDataType_FusionData;
};

template<> struct PrivateDataTypeTraits<ppl::nn::pmx::arm::ConvData> {
  static const PrivateDataType enum_value = PrivateDataType_ConvData;
};

template<> struct PrivateDataTypeTraits<ppl::nn::pmx::arm::FullConnectData> {
  static const PrivateDataType enum_value = PrivateDataType_FullConnectData;
};

template<> struct PrivateDataTypeTraits<ppl::nn::pmx::arm::PmxOpData> {
  static const PrivateDataType enum_value = PrivateDataType_PmxOpData;
};

bool VerifyPrivateDataType(flatbuffers::Verifier &verifier, const void *obj, PrivateDataType type);
bool VerifyPrivateDataTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct OutputData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutputDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTYPE = 4,
    VT_DFORMAT = 6
  };
  const flatbuffers::Vector<uint32_t> *dtype() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DTYPE);
  }
  const flatbuffers::Vector<uint32_t> *dformat() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DFORMAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DTYPE) &&
           verifier.VerifyVector(dtype()) &&
           VerifyOffset(verifier, VT_DFORMAT) &&
           verifier.VerifyVector(dformat()) &&
           verifier.EndTable();
  }
};

struct OutputDataBuilder {
  typedef OutputData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dtype(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dtype) {
    fbb_.AddOffset(OutputData::VT_DTYPE, dtype);
  }
  void add_dformat(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dformat) {
    fbb_.AddOffset(OutputData::VT_DFORMAT, dformat);
  }
  explicit OutputDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OutputData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutputData>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutputData> CreateOutputData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dtype = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dformat = 0) {
  OutputDataBuilder builder_(_fbb);
  builder_.add_dformat(dformat);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

inline flatbuffers::Offset<OutputData> CreateOutputDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *dtype = nullptr,
    const std::vector<uint32_t> *dformat = nullptr) {
  auto dtype__ = dtype ? _fbb.CreateVector<uint32_t>(*dtype) : 0;
  auto dformat__ = dformat ? _fbb.CreateVector<uint32_t>(*dformat) : 0;
  return ppl::nn::pmx::arm::CreateOutputData(
      _fbb,
      dtype__,
      dformat__);
}

struct FusionData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FusionDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSE_RELU = 4,
    VT_DTYPE = 6,
    VT_DFORMAT = 8
  };
  int8_t fuse_relu() const {
    return GetField<int8_t>(VT_FUSE_RELU, 0);
  }
  const flatbuffers::Vector<uint32_t> *dtype() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DTYPE);
  }
  const flatbuffers::Vector<uint32_t> *dformat() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DFORMAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSE_RELU) &&
           VerifyOffset(verifier, VT_DTYPE) &&
           verifier.VerifyVector(dtype()) &&
           VerifyOffset(verifier, VT_DFORMAT) &&
           verifier.VerifyVector(dformat()) &&
           verifier.EndTable();
  }
};

struct FusionDataBuilder {
  typedef FusionData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fuse_relu(int8_t fuse_relu) {
    fbb_.AddElement<int8_t>(FusionData::VT_FUSE_RELU, fuse_relu, 0);
  }
  void add_dtype(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dtype) {
    fbb_.AddOffset(FusionData::VT_DTYPE, dtype);
  }
  void add_dformat(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dformat) {
    fbb_.AddOffset(FusionData::VT_DFORMAT, dformat);
  }
  explicit FusionDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FusionData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FusionData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FusionData> CreateFusionData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t fuse_relu = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dtype = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dformat = 0) {
  FusionDataBuilder builder_(_fbb);
  builder_.add_dformat(dformat);
  builder_.add_dtype(dtype);
  builder_.add_fuse_relu(fuse_relu);
  return builder_.Finish();
}

inline flatbuffers::Offset<FusionData> CreateFusionDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t fuse_relu = 0,
    const std::vector<uint32_t> *dtype = nullptr,
    const std::vector<uint32_t> *dformat = nullptr) {
  auto dtype__ = dtype ? _fbb.CreateVector<uint32_t>(*dtype) : 0;
  auto dformat__ = dformat ? _fbb.CreateVector<uint32_t>(*dformat) : 0;
  return ppl::nn::pmx::arm::CreateFusionData(
      _fbb,
      fuse_relu,
      dtype__,
      dformat__);
}

struct ConvAlgoInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConvAlgoInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALGO_TYPE = 4,
    VT_DTYPE = 6,
    VT_ISA = 8,
    VT_SCHED_PARAM = 10
  };
  uint32_t algo_type() const {
    return GetField<uint32_t>(VT_ALGO_TYPE, 0);
  }
  uint32_t dtype() const {
    return GetField<uint32_t>(VT_DTYPE, 0);
  }
  uint32_t isa() const {
    return GetField<uint32_t>(VT_ISA, 0);
  }
  const flatbuffers::Vector<int64_t> *sched_param() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SCHED_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ALGO_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_DTYPE) &&
           VerifyField<uint32_t>(verifier, VT_ISA) &&
           VerifyOffset(verifier, VT_SCHED_PARAM) &&
           verifier.VerifyVector(sched_param()) &&
           verifier.EndTable();
  }
};

struct ConvAlgoInfoBuilder {
  typedef ConvAlgoInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_algo_type(uint32_t algo_type) {
    fbb_.AddElement<uint32_t>(ConvAlgoInfo::VT_ALGO_TYPE, algo_type, 0);
  }
  void add_dtype(uint32_t dtype) {
    fbb_.AddElement<uint32_t>(ConvAlgoInfo::VT_DTYPE, dtype, 0);
  }
  void add_isa(uint32_t isa) {
    fbb_.AddElement<uint32_t>(ConvAlgoInfo::VT_ISA, isa, 0);
  }
  void add_sched_param(flatbuffers::Offset<flatbuffers::Vector<int64_t>> sched_param) {
    fbb_.AddOffset(ConvAlgoInfo::VT_SCHED_PARAM, sched_param);
  }
  explicit ConvAlgoInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConvAlgoInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConvAlgoInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConvAlgoInfo> CreateConvAlgoInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t algo_type = 0,
    uint32_t dtype = 0,
    uint32_t isa = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> sched_param = 0) {
  ConvAlgoInfoBuilder builder_(_fbb);
  builder_.add_sched_param(sched_param);
  builder_.add_isa(isa);
  builder_.add_dtype(dtype);
  builder_.add_algo_type(algo_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConvAlgoInfo> CreateConvAlgoInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t algo_type = 0,
    uint32_t dtype = 0,
    uint32_t isa = 0,
    const std::vector<int64_t> *sched_param = nullptr) {
  auto sched_param__ = sched_param ? _fbb.CreateVector<int64_t>(*sched_param) : 0;
  return ppl::nn::pmx::arm::CreateConvAlgoInfo(
      _fbb,
      algo_type,
      dtype,
      isa,
      sched_param__);
}

struct ConvParamInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConvParamInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_OUTPUT = 4,
    VT_CHANNELS = 6,
    VT_PAD_TYPE = 8,
    VT_FUSE_TYPE = 10,
    VT_HAS_BIAS = 12
  };
  int64_t num_output() const {
    return GetField<int64_t>(VT_NUM_OUTPUT, 0);
  }
  int64_t channels() const {
    return GetField<int64_t>(VT_CHANNELS, 0);
  }
  uint32_t pad_type() const {
    return GetField<uint32_t>(VT_PAD_TYPE, 0);
  }
  uint32_t fuse_type() const {
    return GetField<uint32_t>(VT_FUSE_TYPE, 0);
  }
  int8_t has_bias() const {
    return GetField<int8_t>(VT_HAS_BIAS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_NUM_OUTPUT) &&
           VerifyField<int64_t>(verifier, VT_CHANNELS) &&
           VerifyField<uint32_t>(verifier, VT_PAD_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_FUSE_TYPE) &&
           VerifyField<int8_t>(verifier, VT_HAS_BIAS) &&
           verifier.EndTable();
  }
};

struct ConvParamInfoBuilder {
  typedef ConvParamInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_output(int64_t num_output) {
    fbb_.AddElement<int64_t>(ConvParamInfo::VT_NUM_OUTPUT, num_output, 0);
  }
  void add_channels(int64_t channels) {
    fbb_.AddElement<int64_t>(ConvParamInfo::VT_CHANNELS, channels, 0);
  }
  void add_pad_type(uint32_t pad_type) {
    fbb_.AddElement<uint32_t>(ConvParamInfo::VT_PAD_TYPE, pad_type, 0);
  }
  void add_fuse_type(uint32_t fuse_type) {
    fbb_.AddElement<uint32_t>(ConvParamInfo::VT_FUSE_TYPE, fuse_type, 0);
  }
  void add_has_bias(int8_t has_bias) {
    fbb_.AddElement<int8_t>(ConvParamInfo::VT_HAS_BIAS, has_bias, 0);
  }
  explicit ConvParamInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConvParamInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConvParamInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConvParamInfo> CreateConvParamInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t num_output = 0,
    int64_t channels = 0,
    uint32_t pad_type = 0,
    uint32_t fuse_type = 0,
    int8_t has_bias = 0) {
  ConvParamInfoBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_num_output(num_output);
  builder_.add_fuse_type(fuse_type);
  builder_.add_pad_type(pad_type);
  builder_.add_has_bias(has_bias);
  return builder_.Finish();
}

struct ConvData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConvDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALGO_INFO = 4,
    VT_PARAM_INFO = 6
  };
  const ppl::nn::pmx::arm::ConvAlgoInfo *algo_info() const {
    return GetPointer<const ppl::nn::pmx::arm::ConvAlgoInfo *>(VT_ALGO_INFO);
  }
  const ppl::nn::pmx::arm::ConvParamInfo *param_info() const {
    return GetPointer<const ppl::nn::pmx::arm::ConvParamInfo *>(VT_PARAM_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ALGO_INFO) &&
           verifier.VerifyTable(algo_info()) &&
           VerifyOffset(verifier, VT_PARAM_INFO) &&
           verifier.VerifyTable(param_info()) &&
           verifier.EndTable();
  }
};

struct ConvDataBuilder {
  typedef ConvData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_algo_info(flatbuffers::Offset<ppl::nn::pmx::arm::ConvAlgoInfo> algo_info) {
    fbb_.AddOffset(ConvData::VT_ALGO_INFO, algo_info);
  }
  void add_param_info(flatbuffers::Offset<ppl::nn::pmx::arm::ConvParamInfo> param_info) {
    fbb_.AddOffset(ConvData::VT_PARAM_INFO, param_info);
  }
  explicit ConvDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConvData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConvData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConvData> CreateConvData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ppl::nn::pmx::arm::ConvAlgoInfo> algo_info = 0,
    flatbuffers::Offset<ppl::nn::pmx::arm::ConvParamInfo> param_info = 0) {
  ConvDataBuilder builder_(_fbb);
  builder_.add_param_info(param_info);
  builder_.add_algo_info(algo_info);
  return builder_.Finish();
}

struct FCAlgoInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FCAlgoInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALGO_TYPE = 4,
    VT_DTYPE = 6,
    VT_DFORMAT = 8,
    VT_ISA = 10
  };
  uint32_t algo_type() const {
    return GetField<uint32_t>(VT_ALGO_TYPE, 0);
  }
  uint32_t dtype() const {
    return GetField<uint32_t>(VT_DTYPE, 0);
  }
  uint32_t dformat() const {
    return GetField<uint32_t>(VT_DFORMAT, 0);
  }
  uint32_t isa() const {
    return GetField<uint32_t>(VT_ISA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ALGO_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_DTYPE) &&
           VerifyField<uint32_t>(verifier, VT_DFORMAT) &&
           VerifyField<uint32_t>(verifier, VT_ISA) &&
           verifier.EndTable();
  }
};

struct FCAlgoInfoBuilder {
  typedef FCAlgoInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_algo_type(uint32_t algo_type) {
    fbb_.AddElement<uint32_t>(FCAlgoInfo::VT_ALGO_TYPE, algo_type, 0);
  }
  void add_dtype(uint32_t dtype) {
    fbb_.AddElement<uint32_t>(FCAlgoInfo::VT_DTYPE, dtype, 0);
  }
  void add_dformat(uint32_t dformat) {
    fbb_.AddElement<uint32_t>(FCAlgoInfo::VT_DFORMAT, dformat, 0);
  }
  void add_isa(uint32_t isa) {
    fbb_.AddElement<uint32_t>(FCAlgoInfo::VT_ISA, isa, 0);
  }
  explicit FCAlgoInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FCAlgoInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FCAlgoInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<FCAlgoInfo> CreateFCAlgoInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t algo_type = 0,
    uint32_t dtype = 0,
    uint32_t dformat = 0,
    uint32_t isa = 0) {
  FCAlgoInfoBuilder builder_(_fbb);
  builder_.add_isa(isa);
  builder_.add_dformat(dformat);
  builder_.add_dtype(dtype);
  builder_.add_algo_type(algo_type);
  return builder_.Finish();
}

struct FCParamInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FCParamInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_OUTPUT = 4,
    VT_CHANNELS = 6,
    VT_FUSE_FLAG = 8,
    VT_BIAS_TERM = 10
  };
  int64_t num_output() const {
    return GetField<int64_t>(VT_NUM_OUTPUT, 0);
  }
  int64_t channels() const {
    return GetField<int64_t>(VT_CHANNELS, 0);
  }
  uint32_t fuse_flag() const {
    return GetField<uint32_t>(VT_FUSE_FLAG, 0);
  }
  int8_t bias_term() const {
    return GetField<int8_t>(VT_BIAS_TERM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_NUM_OUTPUT) &&
           VerifyField<int64_t>(verifier, VT_CHANNELS) &&
           VerifyField<uint32_t>(verifier, VT_FUSE_FLAG) &&
           VerifyField<int8_t>(verifier, VT_BIAS_TERM) &&
           verifier.EndTable();
  }
};

struct FCParamInfoBuilder {
  typedef FCParamInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_output(int64_t num_output) {
    fbb_.AddElement<int64_t>(FCParamInfo::VT_NUM_OUTPUT, num_output, 0);
  }
  void add_channels(int64_t channels) {
    fbb_.AddElement<int64_t>(FCParamInfo::VT_CHANNELS, channels, 0);
  }
  void add_fuse_flag(uint32_t fuse_flag) {
    fbb_.AddElement<uint32_t>(FCParamInfo::VT_FUSE_FLAG, fuse_flag, 0);
  }
  void add_bias_term(int8_t bias_term) {
    fbb_.AddElement<int8_t>(FCParamInfo::VT_BIAS_TERM, bias_term, 0);
  }
  explicit FCParamInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FCParamInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FCParamInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<FCParamInfo> CreateFCParamInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t num_output = 0,
    int64_t channels = 0,
    uint32_t fuse_flag = 0,
    int8_t bias_term = 0) {
  FCParamInfoBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_num_output(num_output);
  builder_.add_fuse_flag(fuse_flag);
  builder_.add_bias_term(bias_term);
  return builder_.Finish();
}

struct FullConnectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FullConnectDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALGO_INFO = 4,
    VT_PARAM_INFO = 6
  };
  const ppl::nn::pmx::arm::FCAlgoInfo *algo_info() const {
    return GetPointer<const ppl::nn::pmx::arm::FCAlgoInfo *>(VT_ALGO_INFO);
  }
  const ppl::nn::pmx::arm::FCParamInfo *param_info() const {
    return GetPointer<const ppl::nn::pmx::arm::FCParamInfo *>(VT_PARAM_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ALGO_INFO) &&
           verifier.VerifyTable(algo_info()) &&
           VerifyOffset(verifier, VT_PARAM_INFO) &&
           verifier.VerifyTable(param_info()) &&
           verifier.EndTable();
  }
};

struct FullConnectDataBuilder {
  typedef FullConnectData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_algo_info(flatbuffers::Offset<ppl::nn::pmx::arm::FCAlgoInfo> algo_info) {
    fbb_.AddOffset(FullConnectData::VT_ALGO_INFO, algo_info);
  }
  void add_param_info(flatbuffers::Offset<ppl::nn::pmx::arm::FCParamInfo> param_info) {
    fbb_.AddOffset(FullConnectData::VT_PARAM_INFO, param_info);
  }
  explicit FullConnectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FullConnectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullConnectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullConnectData> CreateFullConnectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ppl::nn::pmx::arm::FCAlgoInfo> algo_info = 0,
    flatbuffers::Offset<ppl::nn::pmx::arm::FCParamInfo> param_info = 0) {
  FullConnectDataBuilder builder_(_fbb);
  builder_.add_param_info(param_info);
  builder_.add_algo_info(algo_info);
  return builder_.Finish();
}

struct ChannelShuffleParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChannelShuffleParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUP = 4
  };
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           verifier.EndTable();
  }
};

struct ChannelShuffleParamBuilder {
  typedef ChannelShuffleParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(ChannelShuffleParam::VT_GROUP, group, 0);
  }
  explicit ChannelShuffleParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChannelShuffleParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChannelShuffleParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChannelShuffleParam> CreateChannelShuffleParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t group = 0) {
  ChannelShuffleParamBuilder builder_(_fbb);
  builder_.add_group(group);
  return builder_.Finish();
}

struct ShapeMatrixP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShapeMatrixPBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EDGE = 4,
    VT_NUMERATOR = 6,
    VT_DENOMINATOR = 8,
    VT_REAL_DIM = 10,
    VT_SCALAR = 12
  };
  uint32_t edge() const {
    return GetField<uint32_t>(VT_EDGE, 0);
  }
  const flatbuffers::Vector<int64_t> *numerator() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_NUMERATOR);
  }
  const flatbuffers::Vector<int64_t> *denominator() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DENOMINATOR);
  }
  int64_t real_dim() const {
    return GetField<int64_t>(VT_REAL_DIM, 0);
  }
  int8_t scalar() const {
    return GetField<int8_t>(VT_SCALAR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_EDGE) &&
           VerifyOffset(verifier, VT_NUMERATOR) &&
           verifier.VerifyVector(numerator()) &&
           VerifyOffset(verifier, VT_DENOMINATOR) &&
           verifier.VerifyVector(denominator()) &&
           VerifyField<int64_t>(verifier, VT_REAL_DIM) &&
           VerifyField<int8_t>(verifier, VT_SCALAR) &&
           verifier.EndTable();
  }
};

struct ShapeMatrixPBuilder {
  typedef ShapeMatrixP Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_edge(uint32_t edge) {
    fbb_.AddElement<uint32_t>(ShapeMatrixP::VT_EDGE, edge, 0);
  }
  void add_numerator(flatbuffers::Offset<flatbuffers::Vector<int64_t>> numerator) {
    fbb_.AddOffset(ShapeMatrixP::VT_NUMERATOR, numerator);
  }
  void add_denominator(flatbuffers::Offset<flatbuffers::Vector<int64_t>> denominator) {
    fbb_.AddOffset(ShapeMatrixP::VT_DENOMINATOR, denominator);
  }
  void add_real_dim(int64_t real_dim) {
    fbb_.AddElement<int64_t>(ShapeMatrixP::VT_REAL_DIM, real_dim, 0);
  }
  void add_scalar(int8_t scalar) {
    fbb_.AddElement<int8_t>(ShapeMatrixP::VT_SCALAR, scalar, 0);
  }
  explicit ShapeMatrixPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ShapeMatrixP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShapeMatrixP>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShapeMatrixP> CreateShapeMatrixP(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t edge = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> numerator = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> denominator = 0,
    int64_t real_dim = 0,
    int8_t scalar = 0) {
  ShapeMatrixPBuilder builder_(_fbb);
  builder_.add_real_dim(real_dim);
  builder_.add_denominator(denominator);
  builder_.add_numerator(numerator);
  builder_.add_edge(edge);
  builder_.add_scalar(scalar);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShapeMatrixP> CreateShapeMatrixPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t edge = 0,
    const std::vector<int64_t> *numerator = nullptr,
    const std::vector<int64_t> *denominator = nullptr,
    int64_t real_dim = 0,
    int8_t scalar = 0) {
  auto numerator__ = numerator ? _fbb.CreateVector<int64_t>(*numerator) : 0;
  auto denominator__ = denominator ? _fbb.CreateVector<int64_t>(*denominator) : 0;
  return ppl::nn::pmx::arm::CreateShapeMatrixP(
      _fbb,
      edge,
      numerator__,
      denominator__,
      real_dim,
      scalar);
}

struct ShapeOperationParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShapeOperationParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE_MATRIX = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ppl::nn::pmx::arm::ShapeMatrixP>> *shape_matrix() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ppl::nn::pmx::arm::ShapeMatrixP>> *>(VT_SHAPE_MATRIX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE_MATRIX) &&
           verifier.VerifyVector(shape_matrix()) &&
           verifier.VerifyVectorOfTables(shape_matrix()) &&
           verifier.EndTable();
  }
};

struct ShapeOperationParamBuilder {
  typedef ShapeOperationParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape_matrix(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ppl::nn::pmx::arm::ShapeMatrixP>>> shape_matrix) {
    fbb_.AddOffset(ShapeOperationParam::VT_SHAPE_MATRIX, shape_matrix);
  }
  explicit ShapeOperationParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ShapeOperationParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShapeOperationParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShapeOperationParam> CreateShapeOperationParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ppl::nn::pmx::arm::ShapeMatrixP>>> shape_matrix = 0) {
  ShapeOperationParamBuilder builder_(_fbb);
  builder_.add_shape_matrix(shape_matrix);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShapeOperationParam> CreateShapeOperationParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ppl::nn::pmx::arm::ShapeMatrixP>> *shape_matrix = nullptr) {
  auto shape_matrix__ = shape_matrix ? _fbb.CreateVector<flatbuffers::Offset<ppl::nn::pmx::arm::ShapeMatrixP>>(*shape_matrix) : 0;
  return ppl::nn::pmx::arm::CreateShapeOperationParam(
      _fbb,
      shape_matrix__);
}

struct PmxOpData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PmxOpDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTYPE = 4,
    VT_DFORMAT = 6,
    VT_VALUE_TYPE = 8,
    VT_VALUE = 10
  };
  const flatbuffers::Vector<uint32_t> *dtype() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DTYPE);
  }
  const flatbuffers::Vector<uint32_t> *dformat() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DFORMAT);
  }
  ppl::nn::pmx::arm::PmxOpType value_type() const {
    return static_cast<ppl::nn::pmx::arm::PmxOpType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ppl::nn::pmx::arm::ChannelShuffleParam *value_as_ChannelShuffleParam() const {
    return value_type() == ppl::nn::pmx::arm::PmxOpType_ChannelShuffleParam ? static_cast<const ppl::nn::pmx::arm::ChannelShuffleParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::arm::ShapeOperationParam *value_as_ShapeOperationParam() const {
    return value_type() == ppl::nn::pmx::arm::PmxOpType_ShapeOperationParam ? static_cast<const ppl::nn::pmx::arm::ShapeOperationParam *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DTYPE) &&
           verifier.VerifyVector(dtype()) &&
           VerifyOffset(verifier, VT_DFORMAT) &&
           verifier.VerifyVector(dformat()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyPmxOpType(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ppl::nn::pmx::arm::ChannelShuffleParam *PmxOpData::value_as<ppl::nn::pmx::arm::ChannelShuffleParam>() const {
  return value_as_ChannelShuffleParam();
}

template<> inline const ppl::nn::pmx::arm::ShapeOperationParam *PmxOpData::value_as<ppl::nn::pmx::arm::ShapeOperationParam>() const {
  return value_as_ShapeOperationParam();
}

struct PmxOpDataBuilder {
  typedef PmxOpData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dtype(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dtype) {
    fbb_.AddOffset(PmxOpData::VT_DTYPE, dtype);
  }
  void add_dformat(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dformat) {
    fbb_.AddOffset(PmxOpData::VT_DFORMAT, dformat);
  }
  void add_value_type(ppl::nn::pmx::arm::PmxOpType value_type) {
    fbb_.AddElement<uint8_t>(PmxOpData::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(PmxOpData::VT_VALUE, value);
  }
  explicit PmxOpDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PmxOpData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PmxOpData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PmxOpData> CreatePmxOpData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dtype = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dformat = 0,
    ppl::nn::pmx::arm::PmxOpType value_type = ppl::nn::pmx::arm::PmxOpType_NONE,
    flatbuffers::Offset<void> value = 0) {
  PmxOpDataBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_dformat(dformat);
  builder_.add_dtype(dtype);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PmxOpData> CreatePmxOpDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *dtype = nullptr,
    const std::vector<uint32_t> *dformat = nullptr,
    ppl::nn::pmx::arm::PmxOpType value_type = ppl::nn::pmx::arm::PmxOpType_NONE,
    flatbuffers::Offset<void> value = 0) {
  auto dtype__ = dtype ? _fbb.CreateVector<uint32_t>(*dtype) : 0;
  auto dformat__ = dformat ? _fbb.CreateVector<uint32_t>(*dformat) : 0;
  return ppl::nn::pmx::arm::CreatePmxOpData(
      _fbb,
      dtype__,
      dformat__,
      value_type,
      value);
}

struct OpData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  ppl::nn::pmx::arm::PrivateDataType value_type() const {
    return static_cast<ppl::nn::pmx::arm::PrivateDataType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ppl::nn::pmx::arm::OutputData *value_as_OutputData() const {
    return value_type() == ppl::nn::pmx::arm::PrivateDataType_OutputData ? static_cast<const ppl::nn::pmx::arm::OutputData *>(value()) : nullptr;
  }
  const ppl::nn::pmx::arm::FusionData *value_as_FusionData() const {
    return value_type() == ppl::nn::pmx::arm::PrivateDataType_FusionData ? static_cast<const ppl::nn::pmx::arm::FusionData *>(value()) : nullptr;
  }
  const ppl::nn::pmx::arm::ConvData *value_as_ConvData() const {
    return value_type() == ppl::nn::pmx::arm::PrivateDataType_ConvData ? static_cast<const ppl::nn::pmx::arm::ConvData *>(value()) : nullptr;
  }
  const ppl::nn::pmx::arm::FullConnectData *value_as_FullConnectData() const {
    return value_type() == ppl::nn::pmx::arm::PrivateDataType_FullConnectData ? static_cast<const ppl::nn::pmx::arm::FullConnectData *>(value()) : nullptr;
  }
  const ppl::nn::pmx::arm::PmxOpData *value_as_PmxOpData() const {
    return value_type() == ppl::nn::pmx::arm::PrivateDataType_PmxOpData ? static_cast<const ppl::nn::pmx::arm::PmxOpData *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyPrivateDataType(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ppl::nn::pmx::arm::OutputData *OpData::value_as<ppl::nn::pmx::arm::OutputData>() const {
  return value_as_OutputData();
}

template<> inline const ppl::nn::pmx::arm::FusionData *OpData::value_as<ppl::nn::pmx::arm::FusionData>() const {
  return value_as_FusionData();
}

template<> inline const ppl::nn::pmx::arm::ConvData *OpData::value_as<ppl::nn::pmx::arm::ConvData>() const {
  return value_as_ConvData();
}

template<> inline const ppl::nn::pmx::arm::FullConnectData *OpData::value_as<ppl::nn::pmx::arm::FullConnectData>() const {
  return value_as_FullConnectData();
}

template<> inline const ppl::nn::pmx::arm::PmxOpData *OpData::value_as<ppl::nn::pmx::arm::PmxOpData>() const {
  return value_as_PmxOpData();
}

struct OpDataBuilder {
  typedef OpData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(ppl::nn::pmx::arm::PrivateDataType value_type) {
    fbb_.AddElement<uint8_t>(OpData::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(OpData::VT_VALUE, value);
  }
  explicit OpDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpData>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpData> CreateOpData(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::arm::PrivateDataType value_type = ppl::nn::pmx::arm::PrivateDataType_NONE,
    flatbuffers::Offset<void> value = 0) {
  OpDataBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline bool VerifyPmxOpType(flatbuffers::Verifier &verifier, const void *obj, PmxOpType type) {
  switch (type) {
    case PmxOpType_NONE: {
      return true;
    }
    case PmxOpType_ChannelShuffleParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::arm::ChannelShuffleParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PmxOpType_ShapeOperationParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::arm::ShapeOperationParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPmxOpTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPmxOpType(
        verifier,  values->Get(i), types->GetEnum<PmxOpType>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPrivateDataType(flatbuffers::Verifier &verifier, const void *obj, PrivateDataType type) {
  switch (type) {
    case PrivateDataType_NONE: {
      return true;
    }
    case PrivateDataType_OutputData: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::arm::OutputData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrivateDataType_FusionData: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::arm::FusionData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrivateDataType_ConvData: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::arm::ConvData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrivateDataType_FullConnectData: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::arm::FullConnectData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrivateDataType_PmxOpData: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::arm::PmxOpData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPrivateDataTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPrivateDataType(
        verifier,  values->Get(i), types->GetEnum<PrivateDataType>(i))) {
      return false;
    }
  }
  return true;
}

inline const ppl::nn::pmx::arm::OpData *GetOpData(const void *buf) {
  return flatbuffers::GetRoot<ppl::nn::pmx::arm::OpData>(buf);
}

inline const ppl::nn::pmx::arm::OpData *GetSizePrefixedOpData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ppl::nn::pmx::arm::OpData>(buf);
}

inline bool VerifyOpDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ppl::nn::pmx::arm::OpData>(nullptr);
}

inline bool VerifySizePrefixedOpDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ppl::nn::pmx::arm::OpData>(nullptr);
}

inline void FinishOpDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ppl::nn::pmx::arm::OpData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOpDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ppl::nn::pmx::arm::OpData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace arm
}  // namespace pmx
}  // namespace nn
}  // namespace ppl

#endif  // FLATBUFFERS_GENERATED_ARMOPPARAMS_PPL_NN_PMX_ARM_H_
