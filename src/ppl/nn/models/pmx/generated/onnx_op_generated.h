// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ONNXOP_PPL_NN_PMX_ONNX_H_
#define FLATBUFFERS_GENERATED_ONNXOP_PPL_NN_PMX_ONNX_H_

#include "flatbuffers/flatbuffers.h"

#include "types_generated.h"

namespace ppl {
namespace nn {
namespace pmx {
namespace onnx {

struct ArgMaxParam;
struct ArgMaxParamBuilder;

struct BatchNormalizationParam;
struct BatchNormalizationParamBuilder;

struct CastParam;
struct CastParamBuilder;

struct ConcatParam;
struct ConcatParamBuilder;

struct ConvParam;
struct ConvParamBuilder;

struct ConvTransposeParam;
struct ConvTransposeParamBuilder;

struct CumSumParam;
struct CumSumParamBuilder;

struct DepthToSpaceParam;
struct DepthToSpaceParamBuilder;

struct FlattenParam;
struct FlattenParamBuilder;

struct GatherNDParam;
struct GatherNDParamBuilder;

struct GatherParam;
struct GatherParamBuilder;

struct GemmParam;
struct GemmParamBuilder;

struct InstanceNormalizationParam;
struct InstanceNormalizationParamBuilder;

struct LeakyReluParam;
struct LeakyReluParamBuilder;

struct LRNParam;
struct LRNParamBuilder;

struct LSTMParam;
struct LSTMParamBuilder;

struct MaxUnpoolParam;
struct MaxUnpoolParamBuilder;

struct NonMaxSuppressionParam;
struct NonMaxSuppressionParamBuilder;

struct PadParam;
struct PadParamBuilder;

struct PoolingParam;
struct PoolingParamBuilder;

struct ReduceParam;
struct ReduceParamBuilder;

struct ResizeParam;
struct ResizeParamBuilder;

struct RoiAlignParam;
struct RoiAlignParamBuilder;

struct ScatterElementsParam;
struct ScatterElementsParamBuilder;

struct SliceParam;
struct SliceParamBuilder;

struct SoftmaxParam;
struct SoftmaxParamBuilder;

struct SplitParam;
struct SplitParamBuilder;

struct SplitToSequenceParam;
struct SplitToSequenceParamBuilder;

struct SqueezeParam;
struct SqueezeParamBuilder;

struct TopKParam;
struct TopKParamBuilder;

struct TransposeParam;
struct TransposeParamBuilder;

struct UnsqueezeParam;
struct UnsqueezeParamBuilder;

struct OpParam;
struct OpParamBuilder;

enum AutoPadType : uint32_t {
  AutoPadType_NOSET = 0,
  AutoPadType_SAME_UPPER = 1,
  AutoPadType_SAME_LOWER = 2,
  AutoPadType_VALID = 3,
  AutoPadType_MIN = AutoPadType_NOSET,
  AutoPadType_MAX = AutoPadType_VALID
};

inline const AutoPadType (&EnumValuesAutoPadType())[4] {
  static const AutoPadType values[] = {
    AutoPadType_NOSET,
    AutoPadType_SAME_UPPER,
    AutoPadType_SAME_LOWER,
    AutoPadType_VALID
  };
  return values;
}

inline const char * const *EnumNamesAutoPadType() {
  static const char * const names[5] = {
    "NOSET",
    "SAME_UPPER",
    "SAME_LOWER",
    "VALID",
    nullptr
  };
  return names;
}

inline const char *EnumNameAutoPadType(AutoPadType e) {
  if (flatbuffers::IsOutRange(e, AutoPadType_NOSET, AutoPadType_VALID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAutoPadType()[index];
}

enum DepthToSpaceMode : uint32_t {
  DepthToSpaceMode_DCR = 0,
  DepthToSpaceMode_CRD = 1,
  DepthToSpaceMode_MIN = DepthToSpaceMode_DCR,
  DepthToSpaceMode_MAX = DepthToSpaceMode_CRD
};

inline const DepthToSpaceMode (&EnumValuesDepthToSpaceMode())[2] {
  static const DepthToSpaceMode values[] = {
    DepthToSpaceMode_DCR,
    DepthToSpaceMode_CRD
  };
  return values;
}

inline const char * const *EnumNamesDepthToSpaceMode() {
  static const char * const names[3] = {
    "DCR",
    "CRD",
    nullptr
  };
  return names;
}

inline const char *EnumNameDepthToSpaceMode(DepthToSpaceMode e) {
  if (flatbuffers::IsOutRange(e, DepthToSpaceMode_DCR, DepthToSpaceMode_CRD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDepthToSpaceMode()[index];
}

enum LSTMActivationType : uint32_t {
  LSTMActivationType_RELU = 0,
  LSTMActivationType_TANH = 1,
  LSTMActivationType_SIGMOID = 2,
  LSTMActivationType_AFFINE = 3,
  LSTMActivationType_LEAKY_RELU = 4,
  LSTMActivationType_THRESHOLDED_RELU = 5,
  LSTMActivationType_SCALED_TANH = 6,
  LSTMActivationType_HARD_SIGMOID = 7,
  LSTMActivationType_ELU = 8,
  LSTMActivationType_SOFTSIGN = 9,
  LSTMActivationType_SOFTPLUS = 10,
  LSTMActivationType_MIN = LSTMActivationType_RELU,
  LSTMActivationType_MAX = LSTMActivationType_SOFTPLUS
};

inline const LSTMActivationType (&EnumValuesLSTMActivationType())[11] {
  static const LSTMActivationType values[] = {
    LSTMActivationType_RELU,
    LSTMActivationType_TANH,
    LSTMActivationType_SIGMOID,
    LSTMActivationType_AFFINE,
    LSTMActivationType_LEAKY_RELU,
    LSTMActivationType_THRESHOLDED_RELU,
    LSTMActivationType_SCALED_TANH,
    LSTMActivationType_HARD_SIGMOID,
    LSTMActivationType_ELU,
    LSTMActivationType_SOFTSIGN,
    LSTMActivationType_SOFTPLUS
  };
  return values;
}

inline const char * const *EnumNamesLSTMActivationType() {
  static const char * const names[12] = {
    "RELU",
    "TANH",
    "SIGMOID",
    "AFFINE",
    "LEAKY_RELU",
    "THRESHOLDED_RELU",
    "SCALED_TANH",
    "HARD_SIGMOID",
    "ELU",
    "SOFTSIGN",
    "SOFTPLUS",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSTMActivationType(LSTMActivationType e) {
  if (flatbuffers::IsOutRange(e, LSTMActivationType_RELU, LSTMActivationType_SOFTPLUS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSTMActivationType()[index];
}

enum LSTMDirectionType : uint32_t {
  LSTMDirectionType_FORWARD = 0,
  LSTMDirectionType_REVERSE = 1,
  LSTMDirectionType_BIDIRECTIONAL = 2,
  LSTMDirectionType_MIN = LSTMDirectionType_FORWARD,
  LSTMDirectionType_MAX = LSTMDirectionType_BIDIRECTIONAL
};

inline const LSTMDirectionType (&EnumValuesLSTMDirectionType())[3] {
  static const LSTMDirectionType values[] = {
    LSTMDirectionType_FORWARD,
    LSTMDirectionType_REVERSE,
    LSTMDirectionType_BIDIRECTIONAL
  };
  return values;
}

inline const char * const *EnumNamesLSTMDirectionType() {
  static const char * const names[4] = {
    "FORWARD",
    "REVERSE",
    "BIDIRECTIONAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSTMDirectionType(LSTMDirectionType e) {
  if (flatbuffers::IsOutRange(e, LSTMDirectionType_FORWARD, LSTMDirectionType_BIDIRECTIONAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSTMDirectionType()[index];
}

enum PadMode : uint32_t {
  PadMode_CONSTANT = 0,
  PadMode_REFLECT = 1,
  PadMode_EDGE = 2,
  PadMode_MIN = PadMode_CONSTANT,
  PadMode_MAX = PadMode_EDGE
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_CONSTANT,
    PadMode_REFLECT,
    PadMode_EDGE
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[4] = {
    "CONSTANT",
    "REFLECT",
    "EDGE",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (flatbuffers::IsOutRange(e, PadMode_CONSTANT, PadMode_EDGE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadMode()[index];
}

enum ReduceType : uint32_t {
  ReduceType_REDUCE_SUM = 0,
  ReduceType_REDUCE_MAX = 1,
  ReduceType_REDUCE_MIN = 2,
  ReduceType_REDUCE_PROD = 3,
  ReduceType_REDUCE_MEAN = 4,
  ReduceType_MIN = ReduceType_REDUCE_SUM,
  ReduceType_MAX = ReduceType_REDUCE_MEAN
};

inline const ReduceType (&EnumValuesReduceType())[5] {
  static const ReduceType values[] = {
    ReduceType_REDUCE_SUM,
    ReduceType_REDUCE_MAX,
    ReduceType_REDUCE_MIN,
    ReduceType_REDUCE_PROD,
    ReduceType_REDUCE_MEAN
  };
  return values;
}

inline const char * const *EnumNamesReduceType() {
  static const char * const names[6] = {
    "REDUCE_SUM",
    "REDUCE_MAX",
    "REDUCE_MIN",
    "REDUCE_PROD",
    "REDUCE_MEAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceType(ReduceType e) {
  if (flatbuffers::IsOutRange(e, ReduceType_REDUCE_SUM, ReduceType_REDUCE_MEAN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceType()[index];
}

enum ResizeCoordTransMode : uint32_t {
  ResizeCoordTransMode_HALF_PIXEL = 0,
  ResizeCoordTransMode_PYTORCH_HALF_PIXEL = 1,
  ResizeCoordTransMode_ALIGN_CORNERS = 2,
  ResizeCoordTransMode_ASYMMETRIC = 3,
  ResizeCoordTransMode_TF_HALF_PIXEL_FOR_NN = 4,
  ResizeCoordTransMode_TF_CROP_AND_RESIZE = 5,
  ResizeCoordTransMode_MIN = ResizeCoordTransMode_HALF_PIXEL,
  ResizeCoordTransMode_MAX = ResizeCoordTransMode_TF_CROP_AND_RESIZE
};

inline const ResizeCoordTransMode (&EnumValuesResizeCoordTransMode())[6] {
  static const ResizeCoordTransMode values[] = {
    ResizeCoordTransMode_HALF_PIXEL,
    ResizeCoordTransMode_PYTORCH_HALF_PIXEL,
    ResizeCoordTransMode_ALIGN_CORNERS,
    ResizeCoordTransMode_ASYMMETRIC,
    ResizeCoordTransMode_TF_HALF_PIXEL_FOR_NN,
    ResizeCoordTransMode_TF_CROP_AND_RESIZE
  };
  return values;
}

inline const char * const *EnumNamesResizeCoordTransMode() {
  static const char * const names[7] = {
    "HALF_PIXEL",
    "PYTORCH_HALF_PIXEL",
    "ALIGN_CORNERS",
    "ASYMMETRIC",
    "TF_HALF_PIXEL_FOR_NN",
    "TF_CROP_AND_RESIZE",
    nullptr
  };
  return names;
}

inline const char *EnumNameResizeCoordTransMode(ResizeCoordTransMode e) {
  if (flatbuffers::IsOutRange(e, ResizeCoordTransMode_HALF_PIXEL, ResizeCoordTransMode_TF_CROP_AND_RESIZE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResizeCoordTransMode()[index];
}

enum ResizeMode : uint32_t {
  ResizeMode_NEAREST = 0,
  ResizeMode_LINEAR = 1,
  ResizeMode_CUBIC = 2,
  ResizeMode_MIN = ResizeMode_NEAREST,
  ResizeMode_MAX = ResizeMode_CUBIC
};

inline const ResizeMode (&EnumValuesResizeMode())[3] {
  static const ResizeMode values[] = {
    ResizeMode_NEAREST,
    ResizeMode_LINEAR,
    ResizeMode_CUBIC
  };
  return values;
}

inline const char * const *EnumNamesResizeMode() {
  static const char * const names[4] = {
    "NEAREST",
    "LINEAR",
    "CUBIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameResizeMode(ResizeMode e) {
  if (flatbuffers::IsOutRange(e, ResizeMode_NEAREST, ResizeMode_CUBIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResizeMode()[index];
}

enum ResizeNearestMode : uint32_t {
  ResizeNearestMode_ROUND_PREFER_FLOOR = 0,
  ResizeNearestMode_ROUND_PREFER_CEIL = 1,
  ResizeNearestMode_FLOOR = 2,
  ResizeNearestMode_CEIL = 3,
  ResizeNearestMode_MIN = ResizeNearestMode_ROUND_PREFER_FLOOR,
  ResizeNearestMode_MAX = ResizeNearestMode_CEIL
};

inline const ResizeNearestMode (&EnumValuesResizeNearestMode())[4] {
  static const ResizeNearestMode values[] = {
    ResizeNearestMode_ROUND_PREFER_FLOOR,
    ResizeNearestMode_ROUND_PREFER_CEIL,
    ResizeNearestMode_FLOOR,
    ResizeNearestMode_CEIL
  };
  return values;
}

inline const char * const *EnumNamesResizeNearestMode() {
  static const char * const names[5] = {
    "ROUND_PREFER_FLOOR",
    "ROUND_PREFER_CEIL",
    "FLOOR",
    "CEIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameResizeNearestMode(ResizeNearestMode e) {
  if (flatbuffers::IsOutRange(e, ResizeNearestMode_ROUND_PREFER_FLOOR, ResizeNearestMode_CEIL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResizeNearestMode()[index];
}

enum RoiAlignMode : uint32_t {
  RoiAlignMode_ROIALIGN_AVG = 0,
  RoiAlignMode_ROIALIGN_MAX = 1,
  RoiAlignMode_MIN = RoiAlignMode_ROIALIGN_AVG,
  RoiAlignMode_MAX = RoiAlignMode_ROIALIGN_MAX
};

inline const RoiAlignMode (&EnumValuesRoiAlignMode())[2] {
  static const RoiAlignMode values[] = {
    RoiAlignMode_ROIALIGN_AVG,
    RoiAlignMode_ROIALIGN_MAX
  };
  return values;
}

inline const char * const *EnumNamesRoiAlignMode() {
  static const char * const names[3] = {
    "ROIALIGN_AVG",
    "ROIALIGN_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoiAlignMode(RoiAlignMode e) {
  if (flatbuffers::IsOutRange(e, RoiAlignMode_ROIALIGN_AVG, RoiAlignMode_ROIALIGN_MAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoiAlignMode()[index];
}

enum OpParamType : uint8_t {
  OpParamType_NONE = 0,
  OpParamType_ArgMaxParam = 1,
  OpParamType_BatchNormalizationParam = 2,
  OpParamType_CastParam = 3,
  OpParamType_ConcatParam = 4,
  OpParamType_ConvParam = 5,
  OpParamType_ConvTransposeParam = 6,
  OpParamType_CumSumParam = 7,
  OpParamType_DepthToSpaceParam = 8,
  OpParamType_FlattenParam = 9,
  OpParamType_GatherParam = 10,
  OpParamType_GatherNDParam = 11,
  OpParamType_GemmParam = 12,
  OpParamType_InstanceNormalizationParam = 13,
  OpParamType_LeakyReluParam = 14,
  OpParamType_LRNParam = 15,
  OpParamType_LSTMParam = 16,
  OpParamType_MaxUnpoolParam = 17,
  OpParamType_NonMaxSuppressionParam = 18,
  OpParamType_PadParam = 19,
  OpParamType_PoolingParam = 20,
  OpParamType_ReduceParam = 21,
  OpParamType_ResizeParam = 22,
  OpParamType_RoiAlignParam = 23,
  OpParamType_ScatterElementsParam = 24,
  OpParamType_SoftmaxParam = 25,
  OpParamType_SplitParam = 26,
  OpParamType_SplitToSequenceParam = 27,
  OpParamType_SqueezeParam = 28,
  OpParamType_TopKParam = 29,
  OpParamType_TransposeParam = 30,
  OpParamType_UnsqueezeParam = 31,
  OpParamType_MIN = OpParamType_NONE,
  OpParamType_MAX = OpParamType_UnsqueezeParam
};

inline const OpParamType (&EnumValuesOpParamType())[32] {
  static const OpParamType values[] = {
    OpParamType_NONE,
    OpParamType_ArgMaxParam,
    OpParamType_BatchNormalizationParam,
    OpParamType_CastParam,
    OpParamType_ConcatParam,
    OpParamType_ConvParam,
    OpParamType_ConvTransposeParam,
    OpParamType_CumSumParam,
    OpParamType_DepthToSpaceParam,
    OpParamType_FlattenParam,
    OpParamType_GatherParam,
    OpParamType_GatherNDParam,
    OpParamType_GemmParam,
    OpParamType_InstanceNormalizationParam,
    OpParamType_LeakyReluParam,
    OpParamType_LRNParam,
    OpParamType_LSTMParam,
    OpParamType_MaxUnpoolParam,
    OpParamType_NonMaxSuppressionParam,
    OpParamType_PadParam,
    OpParamType_PoolingParam,
    OpParamType_ReduceParam,
    OpParamType_ResizeParam,
    OpParamType_RoiAlignParam,
    OpParamType_ScatterElementsParam,
    OpParamType_SoftmaxParam,
    OpParamType_SplitParam,
    OpParamType_SplitToSequenceParam,
    OpParamType_SqueezeParam,
    OpParamType_TopKParam,
    OpParamType_TransposeParam,
    OpParamType_UnsqueezeParam
  };
  return values;
}

inline const char * const *EnumNamesOpParamType() {
  static const char * const names[33] = {
    "NONE",
    "ArgMaxParam",
    "BatchNormalizationParam",
    "CastParam",
    "ConcatParam",
    "ConvParam",
    "ConvTransposeParam",
    "CumSumParam",
    "DepthToSpaceParam",
    "FlattenParam",
    "GatherParam",
    "GatherNDParam",
    "GemmParam",
    "InstanceNormalizationParam",
    "LeakyReluParam",
    "LRNParam",
    "LSTMParam",
    "MaxUnpoolParam",
    "NonMaxSuppressionParam",
    "PadParam",
    "PoolingParam",
    "ReduceParam",
    "ResizeParam",
    "RoiAlignParam",
    "ScatterElementsParam",
    "SoftmaxParam",
    "SplitParam",
    "SplitToSequenceParam",
    "SqueezeParam",
    "TopKParam",
    "TransposeParam",
    "UnsqueezeParam",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpParamType(OpParamType e) {
  if (flatbuffers::IsOutRange(e, OpParamType_NONE, OpParamType_UnsqueezeParam)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpParamType()[index];
}

template<typename T> struct OpParamTypeTraits {
  static const OpParamType enum_value = OpParamType_NONE;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::ArgMaxParam> {
  static const OpParamType enum_value = OpParamType_ArgMaxParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::BatchNormalizationParam> {
  static const OpParamType enum_value = OpParamType_BatchNormalizationParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::CastParam> {
  static const OpParamType enum_value = OpParamType_CastParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::ConcatParam> {
  static const OpParamType enum_value = OpParamType_ConcatParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::ConvParam> {
  static const OpParamType enum_value = OpParamType_ConvParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::ConvTransposeParam> {
  static const OpParamType enum_value = OpParamType_ConvTransposeParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::CumSumParam> {
  static const OpParamType enum_value = OpParamType_CumSumParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::DepthToSpaceParam> {
  static const OpParamType enum_value = OpParamType_DepthToSpaceParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::FlattenParam> {
  static const OpParamType enum_value = OpParamType_FlattenParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::GatherParam> {
  static const OpParamType enum_value = OpParamType_GatherParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::GatherNDParam> {
  static const OpParamType enum_value = OpParamType_GatherNDParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::GemmParam> {
  static const OpParamType enum_value = OpParamType_GemmParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::InstanceNormalizationParam> {
  static const OpParamType enum_value = OpParamType_InstanceNormalizationParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::LeakyReluParam> {
  static const OpParamType enum_value = OpParamType_LeakyReluParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::LRNParam> {
  static const OpParamType enum_value = OpParamType_LRNParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::LSTMParam> {
  static const OpParamType enum_value = OpParamType_LSTMParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::MaxUnpoolParam> {
  static const OpParamType enum_value = OpParamType_MaxUnpoolParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::NonMaxSuppressionParam> {
  static const OpParamType enum_value = OpParamType_NonMaxSuppressionParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::PadParam> {
  static const OpParamType enum_value = OpParamType_PadParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::PoolingParam> {
  static const OpParamType enum_value = OpParamType_PoolingParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::ReduceParam> {
  static const OpParamType enum_value = OpParamType_ReduceParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::ResizeParam> {
  static const OpParamType enum_value = OpParamType_ResizeParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::RoiAlignParam> {
  static const OpParamType enum_value = OpParamType_RoiAlignParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::ScatterElementsParam> {
  static const OpParamType enum_value = OpParamType_ScatterElementsParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::SoftmaxParam> {
  static const OpParamType enum_value = OpParamType_SoftmaxParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::SplitParam> {
  static const OpParamType enum_value = OpParamType_SplitParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::SplitToSequenceParam> {
  static const OpParamType enum_value = OpParamType_SplitToSequenceParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::SqueezeParam> {
  static const OpParamType enum_value = OpParamType_SqueezeParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::TopKParam> {
  static const OpParamType enum_value = OpParamType_TopKParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::TransposeParam> {
  static const OpParamType enum_value = OpParamType_TransposeParam;
};

template<> struct OpParamTypeTraits<ppl::nn::pmx::onnx::UnsqueezeParam> {
  static const OpParamType enum_value = OpParamType_UnsqueezeParam;
};

bool VerifyOpParamType(flatbuffers::Verifier &verifier, const void *obj, OpParamType type);
bool VerifyOpParamTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ArgMaxParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_KEEPDIMS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t keepdims() const {
    return GetField<int32_t>(VT_KEEPDIMS, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_KEEPDIMS) &&
           verifier.EndTable();
  }
};

struct ArgMaxParamBuilder {
  typedef ArgMaxParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMaxParam::VT_AXIS, axis, 0);
  }
  void add_keepdims(int32_t keepdims) {
    fbb_.AddElement<int32_t>(ArgMaxParam::VT_KEEPDIMS, keepdims, 1);
  }
  explicit ArgMaxParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMaxParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxParam> CreateArgMaxParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t keepdims = 1) {
  ArgMaxParamBuilder builder_(_fbb);
  builder_.add_keepdims(keepdims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct BatchNormalizationParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormalizationParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4,
    VT_MOMENTUM = 6
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 1e-05f);
  }
  float momentum() const {
    return GetField<float>(VT_MOMENTUM, 0.9f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<float>(verifier, VT_MOMENTUM) &&
           verifier.EndTable();
  }
};

struct BatchNormalizationParamBuilder {
  typedef BatchNormalizationParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNormalizationParam::VT_EPSILON, epsilon, 1e-05f);
  }
  void add_momentum(float momentum) {
    fbb_.AddElement<float>(BatchNormalizationParam::VT_MOMENTUM, momentum, 0.9f);
  }
  explicit BatchNormalizationParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchNormalizationParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNormalizationParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNormalizationParam> CreateBatchNormalizationParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 1e-05f,
    float momentum = 0.9f) {
  BatchNormalizationParamBuilder builder_(_fbb);
  builder_.add_momentum(momentum);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

struct CastParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CastParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TO = 4
  };
  int32_t to() const {
    return GetField<int32_t>(VT_TO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TO) &&
           verifier.EndTable();
  }
};

struct CastParamBuilder {
  typedef CastParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_to(int32_t to) {
    fbb_.AddElement<int32_t>(CastParam::VT_TO, to, 0);
  }
  explicit CastParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CastParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CastParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<CastParam> CreateCastParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t to = 0) {
  CastParamBuilder builder_(_fbb);
  builder_.add_to(to);
  return builder_.Finish();
}

struct ConcatParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConcatParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct ConcatParamBuilder {
  typedef ConcatParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ConcatParam::VT_AXIS, axis, 0);
  }
  explicit ConcatParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConcatParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatParam> CreateConcatParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  ConcatParamBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct ConvParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConvParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AUTO_PAD = 4,
    VT_GROUP = 6,
    VT_DILATIONS = 8,
    VT_KERNEL_SHAPE = 10,
    VT_PADS = 12,
    VT_STRIDES = 14
  };
  ppl::nn::pmx::onnx::AutoPadType auto_pad() const {
    return static_cast<ppl::nn::pmx::onnx::AutoPadType>(GetField<uint32_t>(VT_AUTO_PAD, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  const flatbuffers::Vector<int32_t> *dilations() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DILATIONS);
  }
  const flatbuffers::Vector<int32_t> *kernel_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNEL_SHAPE);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_AUTO_PAD) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyOffset(verifier, VT_DILATIONS) &&
           verifier.VerifyVector(dilations()) &&
           VerifyOffset(verifier, VT_KERNEL_SHAPE) &&
           verifier.VerifyVector(kernel_shape()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           verifier.EndTable();
  }
};

struct ConvParamBuilder {
  typedef ConvParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_auto_pad(ppl::nn::pmx::onnx::AutoPadType auto_pad) {
    fbb_.AddElement<uint32_t>(ConvParam::VT_AUTO_PAD, static_cast<uint32_t>(auto_pad), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(ConvParam::VT_GROUP, group, 0);
  }
  void add_dilations(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilations) {
    fbb_.AddOffset(ConvParam::VT_DILATIONS, dilations);
  }
  void add_kernel_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape) {
    fbb_.AddOffset(ConvParam::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(ConvParam::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(ConvParam::VT_STRIDES, strides);
  }
  explicit ConvParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConvParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConvParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConvParam> CreateConvParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::AutoPadType auto_pad = ppl::nn::pmx::onnx::AutoPadType_NOSET,
    int32_t group = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilations = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0) {
  ConvParamBuilder builder_(_fbb);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_dilations(dilations);
  builder_.add_group(group);
  builder_.add_auto_pad(auto_pad);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConvParam> CreateConvParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::AutoPadType auto_pad = ppl::nn::pmx::onnx::AutoPadType_NOSET,
    int32_t group = 0,
    const std::vector<int32_t> *dilations = nullptr,
    const std::vector<int32_t> *kernel_shape = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr) {
  auto dilations__ = dilations ? _fbb.CreateVector<int32_t>(*dilations) : 0;
  auto kernel_shape__ = kernel_shape ? _fbb.CreateVector<int32_t>(*kernel_shape) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return ppl::nn::pmx::onnx::CreateConvParam(
      _fbb,
      auto_pad,
      group,
      dilations__,
      kernel_shape__,
      pads__,
      strides__);
}

struct ConvTransposeParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConvTransposeParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AUTO_PAD = 4,
    VT_GROUP = 6,
    VT_DILATIONS = 8,
    VT_KERNEL_SHAPE = 10,
    VT_OUTPUT_PADDING = 12,
    VT_OUTPUT_SHAPE = 14,
    VT_PADS = 16,
    VT_STRIDES = 18
  };
  ppl::nn::pmx::onnx::AutoPadType auto_pad() const {
    return static_cast<ppl::nn::pmx::onnx::AutoPadType>(GetField<uint32_t>(VT_AUTO_PAD, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  const flatbuffers::Vector<int32_t> *dilations() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DILATIONS);
  }
  const flatbuffers::Vector<int32_t> *kernel_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNEL_SHAPE);
  }
  const flatbuffers::Vector<int32_t> *output_padding() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUT_PADDING);
  }
  const flatbuffers::Vector<int32_t> *output_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUT_SHAPE);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_AUTO_PAD) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyOffset(verifier, VT_DILATIONS) &&
           verifier.VerifyVector(dilations()) &&
           VerifyOffset(verifier, VT_KERNEL_SHAPE) &&
           verifier.VerifyVector(kernel_shape()) &&
           VerifyOffset(verifier, VT_OUTPUT_PADDING) &&
           verifier.VerifyVector(output_padding()) &&
           VerifyOffset(verifier, VT_OUTPUT_SHAPE) &&
           verifier.VerifyVector(output_shape()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           verifier.EndTable();
  }
};

struct ConvTransposeParamBuilder {
  typedef ConvTransposeParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_auto_pad(ppl::nn::pmx::onnx::AutoPadType auto_pad) {
    fbb_.AddElement<uint32_t>(ConvTransposeParam::VT_AUTO_PAD, static_cast<uint32_t>(auto_pad), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(ConvTransposeParam::VT_GROUP, group, 0);
  }
  void add_dilations(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilations) {
    fbb_.AddOffset(ConvTransposeParam::VT_DILATIONS, dilations);
  }
  void add_kernel_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape) {
    fbb_.AddOffset(ConvTransposeParam::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_output_padding(flatbuffers::Offset<flatbuffers::Vector<int32_t>> output_padding) {
    fbb_.AddOffset(ConvTransposeParam::VT_OUTPUT_PADDING, output_padding);
  }
  void add_output_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> output_shape) {
    fbb_.AddOffset(ConvTransposeParam::VT_OUTPUT_SHAPE, output_shape);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(ConvTransposeParam::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(ConvTransposeParam::VT_STRIDES, strides);
  }
  explicit ConvTransposeParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConvTransposeParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConvTransposeParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConvTransposeParam> CreateConvTransposeParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::AutoPadType auto_pad = ppl::nn::pmx::onnx::AutoPadType_NOSET,
    int32_t group = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilations = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> output_padding = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> output_shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0) {
  ConvTransposeParamBuilder builder_(_fbb);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_output_shape(output_shape);
  builder_.add_output_padding(output_padding);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_dilations(dilations);
  builder_.add_group(group);
  builder_.add_auto_pad(auto_pad);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConvTransposeParam> CreateConvTransposeParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::AutoPadType auto_pad = ppl::nn::pmx::onnx::AutoPadType_NOSET,
    int32_t group = 0,
    const std::vector<int32_t> *dilations = nullptr,
    const std::vector<int32_t> *kernel_shape = nullptr,
    const std::vector<int32_t> *output_padding = nullptr,
    const std::vector<int32_t> *output_shape = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr) {
  auto dilations__ = dilations ? _fbb.CreateVector<int32_t>(*dilations) : 0;
  auto kernel_shape__ = kernel_shape ? _fbb.CreateVector<int32_t>(*kernel_shape) : 0;
  auto output_padding__ = output_padding ? _fbb.CreateVector<int32_t>(*output_padding) : 0;
  auto output_shape__ = output_shape ? _fbb.CreateVector<int32_t>(*output_shape) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return ppl::nn::pmx::onnx::CreateConvTransposeParam(
      _fbb,
      auto_pad,
      group,
      dilations__,
      kernel_shape__,
      output_padding__,
      output_shape__,
      pads__,
      strides__);
}

struct CumSumParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CumSumParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  int32_t exclusive() const {
    return GetField<int32_t>(VT_EXCLUSIVE, 0);
  }
  int32_t reverse() const {
    return GetField<int32_t>(VT_REVERSE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EXCLUSIVE) &&
           VerifyField<int32_t>(verifier, VT_REVERSE) &&
           verifier.EndTable();
  }
};

struct CumSumParamBuilder {
  typedef CumSumParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exclusive(int32_t exclusive) {
    fbb_.AddElement<int32_t>(CumSumParam::VT_EXCLUSIVE, exclusive, 0);
  }
  void add_reverse(int32_t reverse) {
    fbb_.AddElement<int32_t>(CumSumParam::VT_REVERSE, reverse, 0);
  }
  explicit CumSumParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CumSumParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CumSumParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<CumSumParam> CreateCumSumParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t exclusive = 0,
    int32_t reverse = 0) {
  CumSumParamBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

struct DepthToSpaceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepthToSpaceParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSIZE = 4,
    VT_MODE = 6
  };
  int32_t blocksize() const {
    return GetField<int32_t>(VT_BLOCKSIZE, 0);
  }
  ppl::nn::pmx::onnx::DepthToSpaceMode mode() const {
    return static_cast<ppl::nn::pmx::onnx::DepthToSpaceMode>(GetField<uint32_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCKSIZE) &&
           VerifyField<uint32_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct DepthToSpaceParamBuilder {
  typedef DepthToSpaceParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blocksize(int32_t blocksize) {
    fbb_.AddElement<int32_t>(DepthToSpaceParam::VT_BLOCKSIZE, blocksize, 0);
  }
  void add_mode(ppl::nn::pmx::onnx::DepthToSpaceMode mode) {
    fbb_.AddElement<uint32_t>(DepthToSpaceParam::VT_MODE, static_cast<uint32_t>(mode), 0);
  }
  explicit DepthToSpaceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DepthToSpaceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpaceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpaceParam> CreateDepthToSpaceParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t blocksize = 0,
    ppl::nn::pmx::onnx::DepthToSpaceMode mode = ppl::nn::pmx::onnx::DepthToSpaceMode_DCR) {
  DepthToSpaceParamBuilder builder_(_fbb);
  builder_.add_mode(mode);
  builder_.add_blocksize(blocksize);
  return builder_.Finish();
}

struct FlattenParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct FlattenParamBuilder {
  typedef FlattenParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(FlattenParam::VT_AXIS, axis, 1);
  }
  explicit FlattenParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlattenParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlattenParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlattenParam> CreateFlattenParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 1) {
  FlattenParamBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct GatherNDParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherNDParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATCH_DIMS = 4
  };
  int32_t batch_dims() const {
    return GetField<int32_t>(VT_BATCH_DIMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIMS) &&
           verifier.EndTable();
  }
};

struct GatherNDParamBuilder {
  typedef GatherNDParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_batch_dims(int32_t batch_dims) {
    fbb_.AddElement<int32_t>(GatherNDParam::VT_BATCH_DIMS, batch_dims, 0);
  }
  explicit GatherNDParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GatherNDParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNDParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNDParam> CreateGatherNDParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batch_dims = 0) {
  GatherNDParamBuilder builder_(_fbb);
  builder_.add_batch_dims(batch_dims);
  return builder_.Finish();
}

struct GatherParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct GatherParamBuilder {
  typedef GatherParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GatherParam::VT_AXIS, axis, 0);
  }
  explicit GatherParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GatherParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherParam> CreateGatherParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  GatherParamBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct GemmParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GemmParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4,
    VT_BETA = 6,
    VT_TRANS_A = 8,
    VT_TRANS_B = 10
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 1.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 1.0f);
  }
  int32_t trans_a() const {
    return GetField<int32_t>(VT_TRANS_A, 0);
  }
  int32_t trans_b() const {
    return GetField<int32_t>(VT_TRANS_B, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyField<int32_t>(verifier, VT_TRANS_A) &&
           VerifyField<int32_t>(verifier, VT_TRANS_B) &&
           verifier.EndTable();
  }
};

struct GemmParamBuilder {
  typedef GemmParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(GemmParam::VT_ALPHA, alpha, 1.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(GemmParam::VT_BETA, beta, 1.0f);
  }
  void add_trans_a(int32_t trans_a) {
    fbb_.AddElement<int32_t>(GemmParam::VT_TRANS_A, trans_a, 0);
  }
  void add_trans_b(int32_t trans_b) {
    fbb_.AddElement<int32_t>(GemmParam::VT_TRANS_B, trans_b, 0);
  }
  explicit GemmParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GemmParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GemmParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<GemmParam> CreateGemmParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 1.0f,
    float beta = 1.0f,
    int32_t trans_a = 0,
    int32_t trans_b = 0) {
  GemmParamBuilder builder_(_fbb);
  builder_.add_trans_b(trans_b);
  builder_.add_trans_a(trans_a);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct InstanceNormalizationParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceNormalizationParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 1e-05f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
};

struct InstanceNormalizationParamBuilder {
  typedef InstanceNormalizationParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(InstanceNormalizationParam::VT_EPSILON, epsilon, 1e-05f);
  }
  explicit InstanceNormalizationParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InstanceNormalizationParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstanceNormalizationParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstanceNormalizationParam> CreateInstanceNormalizationParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 1e-05f) {
  InstanceNormalizationParamBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

struct LeakyReluParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeakyReluParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.01f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct LeakyReluParamBuilder {
  typedef LeakyReluParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LeakyReluParam::VT_ALPHA, alpha, 0.01f);
  }
  explicit LeakyReluParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LeakyReluParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluParam> CreateLeakyReluParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.01f) {
  LeakyReluParamBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct LRNParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LRNParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4,
    VT_BETA = 6,
    VT_BIAS = 8,
    VT_SIZE = 10
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0001f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.75f);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 1.0f);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct LRNParamBuilder {
  typedef LRNParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LRNParam::VT_ALPHA, alpha, 0.0001f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LRNParam::VT_BETA, beta, 0.75f);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LRNParam::VT_BIAS, bias, 1.0f);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(LRNParam::VT_SIZE, size, 0);
  }
  explicit LRNParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LRNParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LRNParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<LRNParam> CreateLRNParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0001f,
    float beta = 0.75f,
    float bias = 1.0f,
    int32_t size = 0) {
  LRNParamBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_bias(bias);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct LSTMParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_ALPHA = 4,
    VT_ACTIVATION_BETA = 6,
    VT_ACTIVATIONS = 8,
    VT_CLIP = 10,
    VT_DIRECTION = 12,
    VT_HIDDEN_SIZE = 14,
    VT_INPUT_FORGET = 16
  };
  const flatbuffers::Vector<float> *activation_alpha() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ACTIVATION_ALPHA);
  }
  const flatbuffers::Vector<float> *activation_beta() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ACTIVATION_BETA);
  }
  const flatbuffers::Vector<uint32_t> *activations() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ACTIVATIONS);
  }
  float clip() const {
    return GetField<float>(VT_CLIP, 0.0f);
  }
  ppl::nn::pmx::onnx::LSTMDirectionType direction() const {
    return static_cast<ppl::nn::pmx::onnx::LSTMDirectionType>(GetField<uint32_t>(VT_DIRECTION, 0));
  }
  int32_t hidden_size() const {
    return GetField<int32_t>(VT_HIDDEN_SIZE, 0);
  }
  int32_t input_forget() const {
    return GetField<int32_t>(VT_INPUT_FORGET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTIVATION_ALPHA) &&
           verifier.VerifyVector(activation_alpha()) &&
           VerifyOffset(verifier, VT_ACTIVATION_BETA) &&
           verifier.VerifyVector(activation_beta()) &&
           VerifyOffset(verifier, VT_ACTIVATIONS) &&
           verifier.VerifyVector(activations()) &&
           VerifyField<float>(verifier, VT_CLIP) &&
           VerifyField<uint32_t>(verifier, VT_DIRECTION) &&
           VerifyField<int32_t>(verifier, VT_HIDDEN_SIZE) &&
           VerifyField<int32_t>(verifier, VT_INPUT_FORGET) &&
           verifier.EndTable();
  }
};

struct LSTMParamBuilder {
  typedef LSTMParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_alpha(flatbuffers::Offset<flatbuffers::Vector<float>> activation_alpha) {
    fbb_.AddOffset(LSTMParam::VT_ACTIVATION_ALPHA, activation_alpha);
  }
  void add_activation_beta(flatbuffers::Offset<flatbuffers::Vector<float>> activation_beta) {
    fbb_.AddOffset(LSTMParam::VT_ACTIVATION_BETA, activation_beta);
  }
  void add_activations(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> activations) {
    fbb_.AddOffset(LSTMParam::VT_ACTIVATIONS, activations);
  }
  void add_clip(float clip) {
    fbb_.AddElement<float>(LSTMParam::VT_CLIP, clip, 0.0f);
  }
  void add_direction(ppl::nn::pmx::onnx::LSTMDirectionType direction) {
    fbb_.AddElement<uint32_t>(LSTMParam::VT_DIRECTION, static_cast<uint32_t>(direction), 0);
  }
  void add_hidden_size(int32_t hidden_size) {
    fbb_.AddElement<int32_t>(LSTMParam::VT_HIDDEN_SIZE, hidden_size, 0);
  }
  void add_input_forget(int32_t input_forget) {
    fbb_.AddElement<int32_t>(LSTMParam::VT_INPUT_FORGET, input_forget, 0);
  }
  explicit LSTMParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LSTMParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMParam> CreateLSTMParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> activation_alpha = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> activation_beta = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> activations = 0,
    float clip = 0.0f,
    ppl::nn::pmx::onnx::LSTMDirectionType direction = ppl::nn::pmx::onnx::LSTMDirectionType_FORWARD,
    int32_t hidden_size = 0,
    int32_t input_forget = 0) {
  LSTMParamBuilder builder_(_fbb);
  builder_.add_input_forget(input_forget);
  builder_.add_hidden_size(hidden_size);
  builder_.add_direction(direction);
  builder_.add_clip(clip);
  builder_.add_activations(activations);
  builder_.add_activation_beta(activation_beta);
  builder_.add_activation_alpha(activation_alpha);
  return builder_.Finish();
}

inline flatbuffers::Offset<LSTMParam> CreateLSTMParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *activation_alpha = nullptr,
    const std::vector<float> *activation_beta = nullptr,
    const std::vector<uint32_t> *activations = nullptr,
    float clip = 0.0f,
    ppl::nn::pmx::onnx::LSTMDirectionType direction = ppl::nn::pmx::onnx::LSTMDirectionType_FORWARD,
    int32_t hidden_size = 0,
    int32_t input_forget = 0) {
  auto activation_alpha__ = activation_alpha ? _fbb.CreateVector<float>(*activation_alpha) : 0;
  auto activation_beta__ = activation_beta ? _fbb.CreateVector<float>(*activation_beta) : 0;
  auto activations__ = activations ? _fbb.CreateVector<uint32_t>(*activations) : 0;
  return ppl::nn::pmx::onnx::CreateLSTMParam(
      _fbb,
      activation_alpha__,
      activation_beta__,
      activations__,
      clip,
      direction,
      hidden_size,
      input_forget);
}

struct MaxUnpoolParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaxUnpoolParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_SHAPE = 4,
    VT_PADS = 6,
    VT_STRIDES = 8
  };
  const flatbuffers::Vector<int32_t> *kernel_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNEL_SHAPE);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_SHAPE) &&
           verifier.VerifyVector(kernel_shape()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           verifier.EndTable();
  }
};

struct MaxUnpoolParamBuilder {
  typedef MaxUnpoolParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape) {
    fbb_.AddOffset(MaxUnpoolParam::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(MaxUnpoolParam::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(MaxUnpoolParam::VT_STRIDES, strides);
  }
  explicit MaxUnpoolParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaxUnpoolParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaxUnpoolParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaxUnpoolParam> CreateMaxUnpoolParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0) {
  MaxUnpoolParamBuilder builder_(_fbb);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_kernel_shape(kernel_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaxUnpoolParam> CreateMaxUnpoolParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *kernel_shape = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr) {
  auto kernel_shape__ = kernel_shape ? _fbb.CreateVector<int32_t>(*kernel_shape) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return ppl::nn::pmx::onnx::CreateMaxUnpoolParam(
      _fbb,
      kernel_shape__,
      pads__,
      strides__);
}

struct NonMaxSuppressionParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonMaxSuppressionParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER_POINT_BOX = 4
  };
  int32_t center_point_box() const {
    return GetField<int32_t>(VT_CENTER_POINT_BOX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CENTER_POINT_BOX) &&
           verifier.EndTable();
  }
};

struct NonMaxSuppressionParamBuilder {
  typedef NonMaxSuppressionParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_center_point_box(int32_t center_point_box) {
    fbb_.AddElement<int32_t>(NonMaxSuppressionParam::VT_CENTER_POINT_BOX, center_point_box, 0);
  }
  explicit NonMaxSuppressionParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NonMaxSuppressionParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionParam> CreateNonMaxSuppressionParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t center_point_box = 0) {
  NonMaxSuppressionParamBuilder builder_(_fbb);
  builder_.add_center_point_box(center_point_box);
  return builder_.Finish();
}

struct PadParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PadParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_PADS = 6,
    VT_VALUE = 8
  };
  ppl::nn::pmx::onnx::PadMode mode() const {
    return static_cast<ppl::nn::pmx::onnx::PadMode>(GetField<uint32_t>(VT_MODE, 0));
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MODE) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct PadParamBuilder {
  typedef PadParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(ppl::nn::pmx::onnx::PadMode mode) {
    fbb_.AddElement<uint32_t>(PadParam::VT_MODE, static_cast<uint32_t>(mode), 0);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(PadParam::VT_PADS, pads);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(PadParam::VT_VALUE, value, 0.0f);
  }
  explicit PadParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PadParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadParam> CreatePadParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::PadMode mode = ppl::nn::pmx::onnx::PadMode_CONSTANT,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    float value = 0.0f) {
  PadParamBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_pads(pads);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<PadParam> CreatePadParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::PadMode mode = ppl::nn::pmx::onnx::PadMode_CONSTANT,
    const std::vector<int32_t> *pads = nullptr,
    float value = 0.0f) {
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return ppl::nn::pmx::onnx::CreatePadParam(
      _fbb,
      mode,
      pads__,
      value);
}

struct PoolingParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoolingParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AUTO_PAD = 4,
    VT_CEIL_MODE = 6,
    VT_COUNT_INCLUDE_PAD = 8,
    VT_STORAGE_ORDER = 10,
    VT_DILATIONS = 12,
    VT_KERNEL_SHAPE = 14,
    VT_PADS = 16,
    VT_STRIDES = 18
  };
  ppl::nn::pmx::onnx::AutoPadType auto_pad() const {
    return static_cast<ppl::nn::pmx::onnx::AutoPadType>(GetField<uint32_t>(VT_AUTO_PAD, 0));
  }
  int32_t ceil_mode() const {
    return GetField<int32_t>(VT_CEIL_MODE, 0);
  }
  int32_t count_include_pad() const {
    return GetField<int32_t>(VT_COUNT_INCLUDE_PAD, 0);
  }
  int32_t storage_order() const {
    return GetField<int32_t>(VT_STORAGE_ORDER, 0);
  }
  const flatbuffers::Vector<int32_t> *dilations() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DILATIONS);
  }
  const flatbuffers::Vector<int32_t> *kernel_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNEL_SHAPE);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_AUTO_PAD) &&
           VerifyField<int32_t>(verifier, VT_CEIL_MODE) &&
           VerifyField<int32_t>(verifier, VT_COUNT_INCLUDE_PAD) &&
           VerifyField<int32_t>(verifier, VT_STORAGE_ORDER) &&
           VerifyOffset(verifier, VT_DILATIONS) &&
           verifier.VerifyVector(dilations()) &&
           VerifyOffset(verifier, VT_KERNEL_SHAPE) &&
           verifier.VerifyVector(kernel_shape()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           verifier.EndTable();
  }
};

struct PoolingParamBuilder {
  typedef PoolingParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_auto_pad(ppl::nn::pmx::onnx::AutoPadType auto_pad) {
    fbb_.AddElement<uint32_t>(PoolingParam::VT_AUTO_PAD, static_cast<uint32_t>(auto_pad), 0);
  }
  void add_ceil_mode(int32_t ceil_mode) {
    fbb_.AddElement<int32_t>(PoolingParam::VT_CEIL_MODE, ceil_mode, 0);
  }
  void add_count_include_pad(int32_t count_include_pad) {
    fbb_.AddElement<int32_t>(PoolingParam::VT_COUNT_INCLUDE_PAD, count_include_pad, 0);
  }
  void add_storage_order(int32_t storage_order) {
    fbb_.AddElement<int32_t>(PoolingParam::VT_STORAGE_ORDER, storage_order, 0);
  }
  void add_dilations(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilations) {
    fbb_.AddOffset(PoolingParam::VT_DILATIONS, dilations);
  }
  void add_kernel_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape) {
    fbb_.AddOffset(PoolingParam::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(PoolingParam::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(PoolingParam::VT_STRIDES, strides);
  }
  explicit PoolingParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PoolingParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoolingParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<PoolingParam> CreatePoolingParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::AutoPadType auto_pad = ppl::nn::pmx::onnx::AutoPadType_NOSET,
    int32_t ceil_mode = 0,
    int32_t count_include_pad = 0,
    int32_t storage_order = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilations = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0) {
  PoolingParamBuilder builder_(_fbb);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_dilations(dilations);
  builder_.add_storage_order(storage_order);
  builder_.add_count_include_pad(count_include_pad);
  builder_.add_ceil_mode(ceil_mode);
  builder_.add_auto_pad(auto_pad);
  return builder_.Finish();
}

inline flatbuffers::Offset<PoolingParam> CreatePoolingParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::AutoPadType auto_pad = ppl::nn::pmx::onnx::AutoPadType_NOSET,
    int32_t ceil_mode = 0,
    int32_t count_include_pad = 0,
    int32_t storage_order = 0,
    const std::vector<int32_t> *dilations = nullptr,
    const std::vector<int32_t> *kernel_shape = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr) {
  auto dilations__ = dilations ? _fbb.CreateVector<int32_t>(*dilations) : 0;
  auto kernel_shape__ = kernel_shape ? _fbb.CreateVector<int32_t>(*kernel_shape) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return ppl::nn::pmx::onnx::CreatePoolingParam(
      _fbb,
      auto_pad,
      ceil_mode,
      count_include_pad,
      storage_order,
      dilations__,
      kernel_shape__,
      pads__,
      strides__);
}

struct ReduceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_KEEPDIMS = 6,
    VT_AXES = 8
  };
  ppl::nn::pmx::onnx::ReduceType type() const {
    return static_cast<ppl::nn::pmx::onnx::ReduceType>(GetField<uint32_t>(VT_TYPE, 0));
  }
  int32_t keepdims() const {
    return GetField<int32_t>(VT_KEEPDIMS, 1);
  }
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_KEEPDIMS) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           verifier.EndTable();
  }
};

struct ReduceParamBuilder {
  typedef ReduceParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ppl::nn::pmx::onnx::ReduceType type) {
    fbb_.AddElement<uint32_t>(ReduceParam::VT_TYPE, static_cast<uint32_t>(type), 0);
  }
  void add_keepdims(int32_t keepdims) {
    fbb_.AddElement<int32_t>(ReduceParam::VT_KEEPDIMS, keepdims, 1);
  }
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(ReduceParam::VT_AXES, axes);
  }
  explicit ReduceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReduceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceParam> CreateReduceParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::ReduceType type = ppl::nn::pmx::onnx::ReduceType_REDUCE_SUM,
    int32_t keepdims = 1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0) {
  ReduceParamBuilder builder_(_fbb);
  builder_.add_axes(axes);
  builder_.add_keepdims(keepdims);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReduceParam> CreateReduceParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::ReduceType type = ppl::nn::pmx::onnx::ReduceType_REDUCE_SUM,
    int32_t keepdims = 1,
    const std::vector<int32_t> *axes = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  return ppl::nn::pmx::onnx::CreateReduceParam(
      _fbb,
      type,
      keepdims,
      axes__);
}

struct ResizeParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORD_TRANS_MODE = 4,
    VT_CUBIC_COEFF_A = 6,
    VT_EXCLUDE_OUTSIDE = 8,
    VT_EXTRAPOLATION_VALUE = 10,
    VT_MODE = 12,
    VT_NEAREST_MODE = 14
  };
  ppl::nn::pmx::onnx::ResizeCoordTransMode coord_trans_mode() const {
    return static_cast<ppl::nn::pmx::onnx::ResizeCoordTransMode>(GetField<uint32_t>(VT_COORD_TRANS_MODE, 0));
  }
  float cubic_coeff_a() const {
    return GetField<float>(VT_CUBIC_COEFF_A, -0.75f);
  }
  int32_t exclude_outside() const {
    return GetField<int32_t>(VT_EXCLUDE_OUTSIDE, 0);
  }
  float extrapolation_value() const {
    return GetField<float>(VT_EXTRAPOLATION_VALUE, 0.0f);
  }
  ppl::nn::pmx::onnx::ResizeMode mode() const {
    return static_cast<ppl::nn::pmx::onnx::ResizeMode>(GetField<uint32_t>(VT_MODE, 0));
  }
  ppl::nn::pmx::onnx::ResizeNearestMode nearest_mode() const {
    return static_cast<ppl::nn::pmx::onnx::ResizeNearestMode>(GetField<uint32_t>(VT_NEAREST_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COORD_TRANS_MODE) &&
           VerifyField<float>(verifier, VT_CUBIC_COEFF_A) &&
           VerifyField<int32_t>(verifier, VT_EXCLUDE_OUTSIDE) &&
           VerifyField<float>(verifier, VT_EXTRAPOLATION_VALUE) &&
           VerifyField<uint32_t>(verifier, VT_MODE) &&
           VerifyField<uint32_t>(verifier, VT_NEAREST_MODE) &&
           verifier.EndTable();
  }
};

struct ResizeParamBuilder {
  typedef ResizeParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coord_trans_mode(ppl::nn::pmx::onnx::ResizeCoordTransMode coord_trans_mode) {
    fbb_.AddElement<uint32_t>(ResizeParam::VT_COORD_TRANS_MODE, static_cast<uint32_t>(coord_trans_mode), 0);
  }
  void add_cubic_coeff_a(float cubic_coeff_a) {
    fbb_.AddElement<float>(ResizeParam::VT_CUBIC_COEFF_A, cubic_coeff_a, -0.75f);
  }
  void add_exclude_outside(int32_t exclude_outside) {
    fbb_.AddElement<int32_t>(ResizeParam::VT_EXCLUDE_OUTSIDE, exclude_outside, 0);
  }
  void add_extrapolation_value(float extrapolation_value) {
    fbb_.AddElement<float>(ResizeParam::VT_EXTRAPOLATION_VALUE, extrapolation_value, 0.0f);
  }
  void add_mode(ppl::nn::pmx::onnx::ResizeMode mode) {
    fbb_.AddElement<uint32_t>(ResizeParam::VT_MODE, static_cast<uint32_t>(mode), 0);
  }
  void add_nearest_mode(ppl::nn::pmx::onnx::ResizeNearestMode nearest_mode) {
    fbb_.AddElement<uint32_t>(ResizeParam::VT_NEAREST_MODE, static_cast<uint32_t>(nearest_mode), 0);
  }
  explicit ResizeParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResizeParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeParam> CreateResizeParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::ResizeCoordTransMode coord_trans_mode = ppl::nn::pmx::onnx::ResizeCoordTransMode_HALF_PIXEL,
    float cubic_coeff_a = -0.75f,
    int32_t exclude_outside = 0,
    float extrapolation_value = 0.0f,
    ppl::nn::pmx::onnx::ResizeMode mode = ppl::nn::pmx::onnx::ResizeMode_NEAREST,
    ppl::nn::pmx::onnx::ResizeNearestMode nearest_mode = ppl::nn::pmx::onnx::ResizeNearestMode_ROUND_PREFER_FLOOR) {
  ResizeParamBuilder builder_(_fbb);
  builder_.add_nearest_mode(nearest_mode);
  builder_.add_mode(mode);
  builder_.add_extrapolation_value(extrapolation_value);
  builder_.add_exclude_outside(exclude_outside);
  builder_.add_cubic_coeff_a(cubic_coeff_a);
  builder_.add_coord_trans_mode(coord_trans_mode);
  return builder_.Finish();
}

struct RoiAlignParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoiAlignParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_OUTPUT_HEIGHT = 6,
    VT_OUTPUT_WIDTH = 8,
    VT_SAMPLING_RATIO = 10,
    VT_SPATIAL_SCALE = 12
  };
  ppl::nn::pmx::onnx::RoiAlignMode mode() const {
    return static_cast<ppl::nn::pmx::onnx::RoiAlignMode>(GetField<uint32_t>(VT_MODE, 0));
  }
  int32_t output_height() const {
    return GetField<int32_t>(VT_OUTPUT_HEIGHT, 1);
  }
  int32_t output_width() const {
    return GetField<int32_t>(VT_OUTPUT_WIDTH, 1);
  }
  int32_t sampling_ratio() const {
    return GetField<int32_t>(VT_SAMPLING_RATIO, 0);
  }
  float spatial_scale() const {
    return GetField<float>(VT_SPATIAL_SCALE, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MODE) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_SAMPLING_RATIO) &&
           VerifyField<float>(verifier, VT_SPATIAL_SCALE) &&
           verifier.EndTable();
  }
};

struct RoiAlignParamBuilder {
  typedef RoiAlignParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(ppl::nn::pmx::onnx::RoiAlignMode mode) {
    fbb_.AddElement<uint32_t>(RoiAlignParam::VT_MODE, static_cast<uint32_t>(mode), 0);
  }
  void add_output_height(int32_t output_height) {
    fbb_.AddElement<int32_t>(RoiAlignParam::VT_OUTPUT_HEIGHT, output_height, 1);
  }
  void add_output_width(int32_t output_width) {
    fbb_.AddElement<int32_t>(RoiAlignParam::VT_OUTPUT_WIDTH, output_width, 1);
  }
  void add_sampling_ratio(int32_t sampling_ratio) {
    fbb_.AddElement<int32_t>(RoiAlignParam::VT_SAMPLING_RATIO, sampling_ratio, 0);
  }
  void add_spatial_scale(float spatial_scale) {
    fbb_.AddElement<float>(RoiAlignParam::VT_SPATIAL_SCALE, spatial_scale, 1.0f);
  }
  explicit RoiAlignParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoiAlignParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoiAlignParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoiAlignParam> CreateRoiAlignParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::RoiAlignMode mode = ppl::nn::pmx::onnx::RoiAlignMode_ROIALIGN_AVG,
    int32_t output_height = 1,
    int32_t output_width = 1,
    int32_t sampling_ratio = 0,
    float spatial_scale = 1.0f) {
  RoiAlignParamBuilder builder_(_fbb);
  builder_.add_spatial_scale(spatial_scale);
  builder_.add_sampling_ratio(sampling_ratio);
  builder_.add_output_width(output_width);
  builder_.add_output_height(output_height);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct ScatterElementsParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScatterElementsParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct ScatterElementsParamBuilder {
  typedef ScatterElementsParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ScatterElementsParam::VT_AXIS, axis, 0);
  }
  explicit ScatterElementsParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScatterElementsParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterElementsParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterElementsParam> CreateScatterElementsParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  ScatterElementsParamBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct SliceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXES = 4,
    VT_ENDS = 6,
    VT_STARTS = 8
  };
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  const flatbuffers::Vector<int32_t> *ends() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENDS);
  }
  const flatbuffers::Vector<int32_t> *starts() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           VerifyOffset(verifier, VT_ENDS) &&
           verifier.VerifyVector(ends()) &&
           VerifyOffset(verifier, VT_STARTS) &&
           verifier.VerifyVector(starts()) &&
           verifier.EndTable();
  }
};

struct SliceParamBuilder {
  typedef SliceParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(SliceParam::VT_AXES, axes);
  }
  void add_ends(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends) {
    fbb_.AddOffset(SliceParam::VT_ENDS, ends);
  }
  void add_starts(flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts) {
    fbb_.AddOffset(SliceParam::VT_STARTS, starts);
  }
  explicit SliceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SliceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceParam> CreateSliceParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ends = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> starts = 0) {
  SliceParamBuilder builder_(_fbb);
  builder_.add_starts(starts);
  builder_.add_ends(ends);
  builder_.add_axes(axes);
  return builder_.Finish();
}

inline flatbuffers::Offset<SliceParam> CreateSliceParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axes = nullptr,
    const std::vector<int32_t> *ends = nullptr,
    const std::vector<int32_t> *starts = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  auto ends__ = ends ? _fbb.CreateVector<int32_t>(*ends) : 0;
  auto starts__ = starts ? _fbb.CreateVector<int32_t>(*starts) : 0;
  return ppl::nn::pmx::onnx::CreateSliceParam(
      _fbb,
      axes__,
      ends__,
      starts__);
}

struct SoftmaxParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct SoftmaxParamBuilder {
  typedef SoftmaxParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SoftmaxParam::VT_AXIS, axis, 1);
  }
  explicit SoftmaxParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SoftmaxParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxParam> CreateSoftmaxParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 1) {
  SoftmaxParamBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct SplitParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_SPLIT_POINT = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *split_point() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SPLIT_POINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_SPLIT_POINT) &&
           verifier.VerifyVector(split_point()) &&
           verifier.EndTable();
  }
};

struct SplitParamBuilder {
  typedef SplitParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SplitParam::VT_AXIS, axis, 0);
  }
  void add_split_point(flatbuffers::Offset<flatbuffers::Vector<int32_t>> split_point) {
    fbb_.AddOffset(SplitParam::VT_SPLIT_POINT, split_point);
  }
  explicit SplitParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SplitParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitParam> CreateSplitParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> split_point = 0) {
  SplitParamBuilder builder_(_fbb);
  builder_.add_split_point(split_point);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<SplitParam> CreateSplitParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    const std::vector<int32_t> *split_point = nullptr) {
  auto split_point__ = split_point ? _fbb.CreateVector<int32_t>(*split_point) : 0;
  return ppl::nn::pmx::onnx::CreateSplitParam(
      _fbb,
      axis,
      split_point__);
}

struct SplitToSequenceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitToSequenceParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_KEEPDIMS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t keepdims() const {
    return GetField<int32_t>(VT_KEEPDIMS, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_KEEPDIMS) &&
           verifier.EndTable();
  }
};

struct SplitToSequenceParamBuilder {
  typedef SplitToSequenceParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SplitToSequenceParam::VT_AXIS, axis, 0);
  }
  void add_keepdims(int32_t keepdims) {
    fbb_.AddElement<int32_t>(SplitToSequenceParam::VT_KEEPDIMS, keepdims, 1);
  }
  explicit SplitToSequenceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SplitToSequenceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitToSequenceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitToSequenceParam> CreateSplitToSequenceParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t keepdims = 1) {
  SplitToSequenceParamBuilder builder_(_fbb);
  builder_.add_keepdims(keepdims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct SqueezeParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqueezeParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXES = 4
  };
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           verifier.EndTable();
  }
};

struct SqueezeParamBuilder {
  typedef SqueezeParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(SqueezeParam::VT_AXES, axes);
  }
  explicit SqueezeParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SqueezeParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqueezeParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqueezeParam> CreateSqueezeParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0) {
  SqueezeParamBuilder builder_(_fbb);
  builder_.add_axes(axes);
  return builder_.Finish();
}

inline flatbuffers::Offset<SqueezeParam> CreateSqueezeParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axes = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  return ppl::nn::pmx::onnx::CreateSqueezeParam(
      _fbb,
      axes__);
}

struct TopKParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopKParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_LARGEST = 6,
    VT_SORTED = 8,
    VT_K = 10
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, -1);
  }
  int32_t largest() const {
    return GetField<int32_t>(VT_LARGEST, 1);
  }
  int32_t sorted() const {
    return GetField<int32_t>(VT_SORTED, 1);
  }
  int32_t k() const {
    return GetField<int32_t>(VT_K, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_LARGEST) &&
           VerifyField<int32_t>(verifier, VT_SORTED) &&
           VerifyField<int32_t>(verifier, VT_K) &&
           verifier.EndTable();
  }
};

struct TopKParamBuilder {
  typedef TopKParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(TopKParam::VT_AXIS, axis, -1);
  }
  void add_largest(int32_t largest) {
    fbb_.AddElement<int32_t>(TopKParam::VT_LARGEST, largest, 1);
  }
  void add_sorted(int32_t sorted) {
    fbb_.AddElement<int32_t>(TopKParam::VT_SORTED, sorted, 1);
  }
  void add_k(int32_t k) {
    fbb_.AddElement<int32_t>(TopKParam::VT_K, k, -1);
  }
  explicit TopKParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopKParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKParam> CreateTopKParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = -1,
    int32_t largest = 1,
    int32_t sorted = 1,
    int32_t k = -1) {
  TopKParamBuilder builder_(_fbb);
  builder_.add_k(k);
  builder_.add_sorted(sorted);
  builder_.add_largest(largest);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct TransposeParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransposeParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERM = 4
  };
  const flatbuffers::Vector<int32_t> *perm() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PERM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PERM) &&
           verifier.VerifyVector(perm()) &&
           verifier.EndTable();
  }
};

struct TransposeParamBuilder {
  typedef TransposeParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_perm(flatbuffers::Offset<flatbuffers::Vector<int32_t>> perm) {
    fbb_.AddOffset(TransposeParam::VT_PERM, perm);
  }
  explicit TransposeParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TransposeParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeParam> CreateTransposeParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> perm = 0) {
  TransposeParamBuilder builder_(_fbb);
  builder_.add_perm(perm);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransposeParam> CreateTransposeParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *perm = nullptr) {
  auto perm__ = perm ? _fbb.CreateVector<int32_t>(*perm) : 0;
  return ppl::nn::pmx::onnx::CreateTransposeParam(
      _fbb,
      perm__);
}

struct UnsqueezeParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsqueezeParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXES = 4
  };
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           verifier.EndTable();
  }
};

struct UnsqueezeParamBuilder {
  typedef UnsqueezeParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(UnsqueezeParam::VT_AXES, axes);
  }
  explicit UnsqueezeParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnsqueezeParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsqueezeParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsqueezeParam> CreateUnsqueezeParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0) {
  UnsqueezeParamBuilder builder_(_fbb);
  builder_.add_axes(axes);
  return builder_.Finish();
}

inline flatbuffers::Offset<UnsqueezeParam> CreateUnsqueezeParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axes = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  return ppl::nn::pmx::onnx::CreateUnsqueezeParam(
      _fbb,
      axes__);
}

struct OpParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6,
    VT_DATA_ = 8
  };
  ppl::nn::pmx::onnx::OpParamType value_type() const {
    return static_cast<ppl::nn::pmx::onnx::OpParamType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ppl::nn::pmx::onnx::ArgMaxParam *value_as_ArgMaxParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_ArgMaxParam ? static_cast<const ppl::nn::pmx::onnx::ArgMaxParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::BatchNormalizationParam *value_as_BatchNormalizationParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_BatchNormalizationParam ? static_cast<const ppl::nn::pmx::onnx::BatchNormalizationParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::CastParam *value_as_CastParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_CastParam ? static_cast<const ppl::nn::pmx::onnx::CastParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::ConcatParam *value_as_ConcatParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_ConcatParam ? static_cast<const ppl::nn::pmx::onnx::ConcatParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::ConvParam *value_as_ConvParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_ConvParam ? static_cast<const ppl::nn::pmx::onnx::ConvParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::ConvTransposeParam *value_as_ConvTransposeParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_ConvTransposeParam ? static_cast<const ppl::nn::pmx::onnx::ConvTransposeParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::CumSumParam *value_as_CumSumParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_CumSumParam ? static_cast<const ppl::nn::pmx::onnx::CumSumParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::DepthToSpaceParam *value_as_DepthToSpaceParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_DepthToSpaceParam ? static_cast<const ppl::nn::pmx::onnx::DepthToSpaceParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::FlattenParam *value_as_FlattenParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_FlattenParam ? static_cast<const ppl::nn::pmx::onnx::FlattenParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::GatherParam *value_as_GatherParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_GatherParam ? static_cast<const ppl::nn::pmx::onnx::GatherParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::GatherNDParam *value_as_GatherNDParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_GatherNDParam ? static_cast<const ppl::nn::pmx::onnx::GatherNDParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::GemmParam *value_as_GemmParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_GemmParam ? static_cast<const ppl::nn::pmx::onnx::GemmParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::InstanceNormalizationParam *value_as_InstanceNormalizationParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_InstanceNormalizationParam ? static_cast<const ppl::nn::pmx::onnx::InstanceNormalizationParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::LeakyReluParam *value_as_LeakyReluParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_LeakyReluParam ? static_cast<const ppl::nn::pmx::onnx::LeakyReluParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::LRNParam *value_as_LRNParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_LRNParam ? static_cast<const ppl::nn::pmx::onnx::LRNParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::LSTMParam *value_as_LSTMParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_LSTMParam ? static_cast<const ppl::nn::pmx::onnx::LSTMParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::MaxUnpoolParam *value_as_MaxUnpoolParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_MaxUnpoolParam ? static_cast<const ppl::nn::pmx::onnx::MaxUnpoolParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::NonMaxSuppressionParam *value_as_NonMaxSuppressionParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_NonMaxSuppressionParam ? static_cast<const ppl::nn::pmx::onnx::NonMaxSuppressionParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::PadParam *value_as_PadParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_PadParam ? static_cast<const ppl::nn::pmx::onnx::PadParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::PoolingParam *value_as_PoolingParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_PoolingParam ? static_cast<const ppl::nn::pmx::onnx::PoolingParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::ReduceParam *value_as_ReduceParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_ReduceParam ? static_cast<const ppl::nn::pmx::onnx::ReduceParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::ResizeParam *value_as_ResizeParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_ResizeParam ? static_cast<const ppl::nn::pmx::onnx::ResizeParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::RoiAlignParam *value_as_RoiAlignParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_RoiAlignParam ? static_cast<const ppl::nn::pmx::onnx::RoiAlignParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::ScatterElementsParam *value_as_ScatterElementsParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_ScatterElementsParam ? static_cast<const ppl::nn::pmx::onnx::ScatterElementsParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::SoftmaxParam *value_as_SoftmaxParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_SoftmaxParam ? static_cast<const ppl::nn::pmx::onnx::SoftmaxParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::SplitParam *value_as_SplitParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_SplitParam ? static_cast<const ppl::nn::pmx::onnx::SplitParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::SplitToSequenceParam *value_as_SplitToSequenceParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_SplitToSequenceParam ? static_cast<const ppl::nn::pmx::onnx::SplitToSequenceParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::SqueezeParam *value_as_SqueezeParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_SqueezeParam ? static_cast<const ppl::nn::pmx::onnx::SqueezeParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::TopKParam *value_as_TopKParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_TopKParam ? static_cast<const ppl::nn::pmx::onnx::TopKParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::TransposeParam *value_as_TransposeParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_TransposeParam ? static_cast<const ppl::nn::pmx::onnx::TransposeParam *>(value()) : nullptr;
  }
  const ppl::nn::pmx::onnx::UnsqueezeParam *value_as_UnsqueezeParam() const {
    return value_type() == ppl::nn::pmx::onnx::OpParamType_UnsqueezeParam ? static_cast<const ppl::nn::pmx::onnx::UnsqueezeParam *>(value()) : nullptr;
  }
  const flatbuffers::Vector<uint8_t> *data_() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA_);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyOpParamType(verifier, value(), value_type()) &&
           VerifyOffset(verifier, VT_DATA_) &&
           verifier.VerifyVector(data_()) &&
           verifier.EndTable();
  }
};

template<> inline const ppl::nn::pmx::onnx::ArgMaxParam *OpParam::value_as<ppl::nn::pmx::onnx::ArgMaxParam>() const {
  return value_as_ArgMaxParam();
}

template<> inline const ppl::nn::pmx::onnx::BatchNormalizationParam *OpParam::value_as<ppl::nn::pmx::onnx::BatchNormalizationParam>() const {
  return value_as_BatchNormalizationParam();
}

template<> inline const ppl::nn::pmx::onnx::CastParam *OpParam::value_as<ppl::nn::pmx::onnx::CastParam>() const {
  return value_as_CastParam();
}

template<> inline const ppl::nn::pmx::onnx::ConcatParam *OpParam::value_as<ppl::nn::pmx::onnx::ConcatParam>() const {
  return value_as_ConcatParam();
}

template<> inline const ppl::nn::pmx::onnx::ConvParam *OpParam::value_as<ppl::nn::pmx::onnx::ConvParam>() const {
  return value_as_ConvParam();
}

template<> inline const ppl::nn::pmx::onnx::ConvTransposeParam *OpParam::value_as<ppl::nn::pmx::onnx::ConvTransposeParam>() const {
  return value_as_ConvTransposeParam();
}

template<> inline const ppl::nn::pmx::onnx::CumSumParam *OpParam::value_as<ppl::nn::pmx::onnx::CumSumParam>() const {
  return value_as_CumSumParam();
}

template<> inline const ppl::nn::pmx::onnx::DepthToSpaceParam *OpParam::value_as<ppl::nn::pmx::onnx::DepthToSpaceParam>() const {
  return value_as_DepthToSpaceParam();
}

template<> inline const ppl::nn::pmx::onnx::FlattenParam *OpParam::value_as<ppl::nn::pmx::onnx::FlattenParam>() const {
  return value_as_FlattenParam();
}

template<> inline const ppl::nn::pmx::onnx::GatherParam *OpParam::value_as<ppl::nn::pmx::onnx::GatherParam>() const {
  return value_as_GatherParam();
}

template<> inline const ppl::nn::pmx::onnx::GatherNDParam *OpParam::value_as<ppl::nn::pmx::onnx::GatherNDParam>() const {
  return value_as_GatherNDParam();
}

template<> inline const ppl::nn::pmx::onnx::GemmParam *OpParam::value_as<ppl::nn::pmx::onnx::GemmParam>() const {
  return value_as_GemmParam();
}

template<> inline const ppl::nn::pmx::onnx::InstanceNormalizationParam *OpParam::value_as<ppl::nn::pmx::onnx::InstanceNormalizationParam>() const {
  return value_as_InstanceNormalizationParam();
}

template<> inline const ppl::nn::pmx::onnx::LeakyReluParam *OpParam::value_as<ppl::nn::pmx::onnx::LeakyReluParam>() const {
  return value_as_LeakyReluParam();
}

template<> inline const ppl::nn::pmx::onnx::LRNParam *OpParam::value_as<ppl::nn::pmx::onnx::LRNParam>() const {
  return value_as_LRNParam();
}

template<> inline const ppl::nn::pmx::onnx::LSTMParam *OpParam::value_as<ppl::nn::pmx::onnx::LSTMParam>() const {
  return value_as_LSTMParam();
}

template<> inline const ppl::nn::pmx::onnx::MaxUnpoolParam *OpParam::value_as<ppl::nn::pmx::onnx::MaxUnpoolParam>() const {
  return value_as_MaxUnpoolParam();
}

template<> inline const ppl::nn::pmx::onnx::NonMaxSuppressionParam *OpParam::value_as<ppl::nn::pmx::onnx::NonMaxSuppressionParam>() const {
  return value_as_NonMaxSuppressionParam();
}

template<> inline const ppl::nn::pmx::onnx::PadParam *OpParam::value_as<ppl::nn::pmx::onnx::PadParam>() const {
  return value_as_PadParam();
}

template<> inline const ppl::nn::pmx::onnx::PoolingParam *OpParam::value_as<ppl::nn::pmx::onnx::PoolingParam>() const {
  return value_as_PoolingParam();
}

template<> inline const ppl::nn::pmx::onnx::ReduceParam *OpParam::value_as<ppl::nn::pmx::onnx::ReduceParam>() const {
  return value_as_ReduceParam();
}

template<> inline const ppl::nn::pmx::onnx::ResizeParam *OpParam::value_as<ppl::nn::pmx::onnx::ResizeParam>() const {
  return value_as_ResizeParam();
}

template<> inline const ppl::nn::pmx::onnx::RoiAlignParam *OpParam::value_as<ppl::nn::pmx::onnx::RoiAlignParam>() const {
  return value_as_RoiAlignParam();
}

template<> inline const ppl::nn::pmx::onnx::ScatterElementsParam *OpParam::value_as<ppl::nn::pmx::onnx::ScatterElementsParam>() const {
  return value_as_ScatterElementsParam();
}

template<> inline const ppl::nn::pmx::onnx::SoftmaxParam *OpParam::value_as<ppl::nn::pmx::onnx::SoftmaxParam>() const {
  return value_as_SoftmaxParam();
}

template<> inline const ppl::nn::pmx::onnx::SplitParam *OpParam::value_as<ppl::nn::pmx::onnx::SplitParam>() const {
  return value_as_SplitParam();
}

template<> inline const ppl::nn::pmx::onnx::SplitToSequenceParam *OpParam::value_as<ppl::nn::pmx::onnx::SplitToSequenceParam>() const {
  return value_as_SplitToSequenceParam();
}

template<> inline const ppl::nn::pmx::onnx::SqueezeParam *OpParam::value_as<ppl::nn::pmx::onnx::SqueezeParam>() const {
  return value_as_SqueezeParam();
}

template<> inline const ppl::nn::pmx::onnx::TopKParam *OpParam::value_as<ppl::nn::pmx::onnx::TopKParam>() const {
  return value_as_TopKParam();
}

template<> inline const ppl::nn::pmx::onnx::TransposeParam *OpParam::value_as<ppl::nn::pmx::onnx::TransposeParam>() const {
  return value_as_TransposeParam();
}

template<> inline const ppl::nn::pmx::onnx::UnsqueezeParam *OpParam::value_as<ppl::nn::pmx::onnx::UnsqueezeParam>() const {
  return value_as_UnsqueezeParam();
}

struct OpParamBuilder {
  typedef OpParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(ppl::nn::pmx::onnx::OpParamType value_type) {
    fbb_.AddElement<uint8_t>(OpParam::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(OpParam::VT_VALUE, value);
  }
  void add_data_(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_) {
    fbb_.AddOffset(OpParam::VT_DATA_, data_);
  }
  explicit OpParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpParam> CreateOpParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::OpParamType value_type = ppl::nn::pmx::onnx::OpParamType_NONE,
    flatbuffers::Offset<void> value = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_ = 0) {
  OpParamBuilder builder_(_fbb);
  builder_.add_data_(data_);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpParam> CreateOpParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppl::nn::pmx::onnx::OpParamType value_type = ppl::nn::pmx::onnx::OpParamType_NONE,
    flatbuffers::Offset<void> value = 0,
    const std::vector<uint8_t> *data_ = nullptr) {
  auto data___ = data_ ? _fbb.CreateVector<uint8_t>(*data_) : 0;
  return ppl::nn::pmx::onnx::CreateOpParam(
      _fbb,
      value_type,
      value,
      data___);
}

inline bool VerifyOpParamType(flatbuffers::Verifier &verifier, const void *obj, OpParamType type) {
  switch (type) {
    case OpParamType_NONE: {
      return true;
    }
    case OpParamType_ArgMaxParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::ArgMaxParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_BatchNormalizationParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::BatchNormalizationParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_CastParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::CastParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_ConcatParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::ConcatParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_ConvParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::ConvParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_ConvTransposeParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::ConvTransposeParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_CumSumParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::CumSumParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_DepthToSpaceParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::DepthToSpaceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_FlattenParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::FlattenParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_GatherParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::GatherParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_GatherNDParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::GatherNDParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_GemmParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::GemmParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_InstanceNormalizationParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::InstanceNormalizationParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_LeakyReluParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::LeakyReluParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_LRNParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::LRNParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_LSTMParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::LSTMParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_MaxUnpoolParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::MaxUnpoolParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_NonMaxSuppressionParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::NonMaxSuppressionParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_PadParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::PadParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_PoolingParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::PoolingParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_ReduceParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::ReduceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_ResizeParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::ResizeParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_RoiAlignParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::RoiAlignParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_ScatterElementsParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::ScatterElementsParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_SoftmaxParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::SoftmaxParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_SplitParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::SplitParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_SplitToSequenceParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::SplitToSequenceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_SqueezeParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::SqueezeParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_TopKParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::TopKParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_TransposeParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::TransposeParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParamType_UnsqueezeParam: {
      auto ptr = reinterpret_cast<const ppl::nn::pmx::onnx::UnsqueezeParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpParamTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpParamType(
        verifier,  values->Get(i), types->GetEnum<OpParamType>(i))) {
      return false;
    }
  }
  return true;
}

inline const ppl::nn::pmx::onnx::OpParam *GetOpParam(const void *buf) {
  return flatbuffers::GetRoot<ppl::nn::pmx::onnx::OpParam>(buf);
}

inline const ppl::nn::pmx::onnx::OpParam *GetSizePrefixedOpParam(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ppl::nn::pmx::onnx::OpParam>(buf);
}

inline bool VerifyOpParamBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ppl::nn::pmx::onnx::OpParam>(nullptr);
}

inline bool VerifySizePrefixedOpParamBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ppl::nn::pmx::onnx::OpParam>(nullptr);
}

inline void FinishOpParamBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ppl::nn::pmx::onnx::OpParam> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOpParamBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ppl::nn::pmx::onnx::OpParam> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace onnx
}  // namespace pmx
}  // namespace nn
}  // namespace ppl

#endif  // FLATBUFFERS_GENERATED_ONNXOP_PPL_NN_PMX_ONNX_H_
