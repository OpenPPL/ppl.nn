// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TYPES_PPL_NN_PMX_H_
#define FLATBUFFERS_GENERATED_TYPES_PPL_NN_PMX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace ppl {
namespace nn {
namespace pmx {

enum DataType : uint32_t {
  DataType_UNKNOWN = 0,
  DataType_BOOL = 1,
  DataType_INT8 = 2,
  DataType_UINT8 = 3,
  DataType_INT16 = 4,
  DataType_UINT16 = 5,
  DataType_INT32 = 6,
  DataType_UINT32 = 7,
  DataType_INT64 = 8,
  DataType_UINT64 = 9,
  DataType_FLOAT16 = 10,
  DataType_FLOAT32 = 11,
  DataType_FLOAT64 = 12,
  DataType_BFLOAT16 = 13,
  DataType_INT4B = 14,
  DataType_COMPLEX64 = 15,
  DataType_COMPLEX128 = 16,
  DataType_MIN = DataType_UNKNOWN,
  DataType_MAX = DataType_COMPLEX128
};

inline const DataType (&EnumValuesDataType())[17] {
  static const DataType values[] = {
    DataType_UNKNOWN,
    DataType_BOOL,
    DataType_INT8,
    DataType_UINT8,
    DataType_INT16,
    DataType_UINT16,
    DataType_INT32,
    DataType_UINT32,
    DataType_INT64,
    DataType_UINT64,
    DataType_FLOAT16,
    DataType_FLOAT32,
    DataType_FLOAT64,
    DataType_BFLOAT16,
    DataType_INT4B,
    DataType_COMPLEX64,
    DataType_COMPLEX128
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[18] = {
    "UNKNOWN",
    "BOOL",
    "INT8",
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT16",
    "FLOAT32",
    "FLOAT64",
    "BFLOAT16",
    "INT4B",
    "COMPLEX64",
    "COMPLEX128",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType_UNKNOWN, DataType_COMPLEX128)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum DataFormat : uint32_t {
  DataFormat_UNKNOWN = 0,
  DataFormat_NDARRAY = 1,
  DataFormat_NHWC8 = 2,
  DataFormat_NHWC16 = 3,
  DataFormat_N2CX = 4,
  DataFormat_N4CX = 5,
  DataFormat_N8CX = 6,
  DataFormat_N16CX = 7,
  DataFormat_N32CX = 8,
  DataFormat_MIN = DataFormat_UNKNOWN,
  DataFormat_MAX = DataFormat_N32CX
};

inline const DataFormat (&EnumValuesDataFormat())[9] {
  static const DataFormat values[] = {
    DataFormat_UNKNOWN,
    DataFormat_NDARRAY,
    DataFormat_NHWC8,
    DataFormat_NHWC16,
    DataFormat_N2CX,
    DataFormat_N4CX,
    DataFormat_N8CX,
    DataFormat_N16CX,
    DataFormat_N32CX
  };
  return values;
}

inline const char * const *EnumNamesDataFormat() {
  static const char * const names[10] = {
    "UNKNOWN",
    "NDARRAY",
    "NHWC8",
    "NHWC16",
    "N2CX",
    "N4CX",
    "N8CX",
    "N16CX",
    "N32CX",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataFormat(DataFormat e) {
  if (flatbuffers::IsOutRange(e, DataFormat_UNKNOWN, DataFormat_N32CX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataFormat()[index];
}

}  // namespace pmx
}  // namespace nn
}  // namespace ppl

#endif  // FLATBUFFERS_GENERATED_TYPES_PPL_NN_PMX_H_
